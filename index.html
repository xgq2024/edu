<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>塔罗抽卡小游戏</title>
    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/hand-pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        
        #canvas-container {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui-container {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        .ui-panel {
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            pointer-events: auto;
        }
        
        #history-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 250px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        #control-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
        }
        
        #info-panel {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            text-align: center;
        }
        
        #mode-switch {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 10px 20px;
            background-color: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        #mode-switch:hover {
            background-color: #45a049;
        }
        
        .card-history-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 5px;
            border-radius: 5px;
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .card-history-image {
            width: 50px;
            height: 75px;
            object-fit: cover;
            margin-right: 10px;
            border-radius: 3px;
        }
        
        .card-history-info {
            flex: 1;
        }
        
        .card-history-name {
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .card-history-orientation {
            font-size: 12px;
            color: #aaa;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
        }
        
        .input-group input {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
        }
        
        .input-group textarea {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background-color: #333;
            color: white;
            min-height: 100px;
            resize: vertical;
        }
        
        .button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            background-color: #2196F3;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .button:hover {
            background-color: #0b7dda;
        }
        
        .button.secondary {
            background-color: #607D8B;
        }
        
        .button.secondary:hover {
            background-color: #455A64;
        }
        
        .button.danger {
            background-color: #F44336;
        }
        
        .button.danger:hover {
            background-color: #d32f2f;
        }
        
        #video-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 150px;
            z-index: 3;
            display: none;
        }
        
        #video {
            width: 100%;
            height: 100%;
            border-radius: 5px;
            transform: scaleX(-1);
        }
        
        #hand-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 4;
            pointer-events: none;
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="ui-container">
        <div id="history-panel" class="ui-panel">
            <h3>抽卡历史</h3>
            <div id="history-list"></div>
        </div>
        <div id="control-panel" class="ui-panel">
            <h3>设置</h3>
            <div class="input-group">
                <label for="number-input">号码数量 (1-100)</label>
                <input type="number" id="number-input" min="1" max="100" value="1">
            </div>
            <div class="input-group">
                <label for="name-list">学生名单 (每行一个名字)</label>
                <textarea id="name-list" placeholder="输入学生名单，每行一个名字"></textarea>
            </div>
            <button id="reset-deck" class="button secondary">重置牌库</button>
            <button id="clear-history" class="button danger">清空历史</button>
        </div>
        <div id="info-panel" class="ui-panel">
            <h2 id="current-card-name">准备抽卡</h2>
            <p id="current-card-meaning">请张开手掌进入抽卡状态，或使用鼠标点击卡牌</p>
        </div>
        <button id="mode-switch">切换到手势模式</button>
    </div>
    <div id="video-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="hand-canvas"></canvas>
    </div>

    <script>
        // 塔罗牌数据
        const tarotCards = [
            {
                id: 0,
                name: "愚人",
                upright: "新的开始、冒险、天真无畏，但也可能盲目乐观。",
                reversed: "鲁莽、缺乏方向、天真幼稚、拒绝承担责任。",
                imageUrl: "https://p26-doubao-search-sign.byteimg.com/pgc-image/2315ea99098848cbaf4da338b05e08ac~tplv-be4g95zd3a-image.jpeg?lk3s=feb11e32&x-expires=1784368056&x-signature=NEefBsJT6jUJpQbLG0ZVO5gMcME%3D"
            },
            {
                id: 1,
                name: "魔术师",
                upright: "创造力、资源整合、显化能力，强调行动力。",
                reversed: "操纵、欺骗、能力不足、计划失败。",
                imageUrl: "https://p26-doubao-search-sign.byteimg.com/labis/fa56f10408d69da6eb8af315c34e462f~tplv-be4g95zd3a-image.jpeg?lk3s=feb11e32&x-expires=1784368056&x-signature=mrBcHXXNtbU0feFihcYq6yKh9lQ%3D"
            },
            {
                id: 8,
                name: "力量",
                upright: "勇气、意志力、内在力量、控制情绪。",
                reversed: "软弱、自我怀疑、缺乏控制力、过度自信。",
                imageUrl: "https://p26-doubao-search-sign.byteimg.com/ecom-shop-material/jpeg_m_c6dcd71d1808b9fa34b88250bdef327c_sx_1359587_www1398-1398~tplv-be4g95zd3a-image.jpeg?lk3s=feb11e32&x-expires=1784368056&x-signature=d8j3Bnn4q7wHZp4knrs9F78jWCk%3D"
            },
            {
                id: 9,
                name: "隐士",
                upright: "内省、独处、寻求指导、智慧。",
                reversed: "孤独、孤立、过度内向、缺乏方向。",
                imageUrl: "https://p26-doubao-search-sign.byteimg.com/labis/image/1c430a4450ddc2042ca90bec49e3e557~tplv-be4g95zd3a-image.jpeg?lk3s=feb11e32&x-expires=1784368056&x-signature=%2FCmxPs46m38iVynPb5ICl6t0Ajo%3D"
            },
            {
                id: 12,
                name: "倒吊人",
                upright: "牺牲、等待、换个角度看问题、灵性成长。",
                reversed: "不必要的牺牲、拖延、徒劳无功、自我中心。",
                imageUrl: "https://p11-doubao-search-sign.byteimg.com/tos-cn-i-be4g95zd3a/2047845569337884676~tplv-be4g95zd3a-image.jpeg?lk3s=feb11e32&x-expires=1784368056&x-signature=dOKHKudnUu8U2DwSeW1p7jMi8AE%3D"
            }
        ];

        // 卡牌背面图片
        const cardBackImageUrl = "https://p26-doubao-search-sign.byteimg.com/labis/3c023a661a477f0e7e238647c9949dba~tplv-be4g95zd3a-image.jpeg?lk3s=feb11e32&x-expires=1784368056&x-signature=p2QJvvRYj8jztrrRGKghgAvcfcU%3D";

        // 全局变量
        let scene, camera, renderer, controls;
        let cardObjects = [];
        let availableCards = [...tarotCards];
        let drawnCards = [];
        let currentMode = 'mouse'; // 'mouse' or 'gesture'
        let detector = null;
        let video = null;
        let handCanvas = null;
        let handContext = null;
        let currentHand = null;
        let isDrawing = false;
        let selectedCard = null;
        let cardParticles = [];
        let numberMode = false;
        let nameMode = false;
        let numbers = [];
        let names = [];
        let currentNumber = 0;
        let currentNameIndex = 0;

        // 手势状态
        const HandState = {
            OPEN: 'open',
            PINCH: 'pinch',
            FIST: 'fist',
            POINT: 'point',
            UNKNOWN: 'unknown'
        };
        let currentHandState = HandState.UNKNOWN;

        // 初始化函数
        async function init() {
            initThreeJS();
            initEventListeners();
            createCards();
            await initGestureDetection();
            animate();
        }

        // 初始化Three.js场景
        function initThreeJS() {
            // 创建场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x121212);

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 添加环境光
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            // 添加方向光
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 初始化事件监听器
        function initEventListeners() {
            // 模式切换按钮
            document.getElementById('mode-switch').addEventListener('click', toggleMode);

            // 重置牌库按钮
            document.getElementById('reset-deck').addEventListener('click', resetDeck);

            // 清空历史按钮
            document.getElementById('clear-history').addEventListener('click', clearHistory);

            // 号码输入
            document.getElementById('number-input').addEventListener('change', function() {
                const count = parseInt(this.value);
                if (count >= 1 && count <= 100) {
                    generateNumbers(count);
                    numberMode = true;
                    nameMode = false;
                }
            });

            // 学生名单输入
            document.getElementById('name-list').addEventListener('change', function() {
                const text = this.value.trim();
                if (text) {
                    names = text.split('\n').filter(name => name.trim() !== '');
                    nameMode = names.length > 0;
                    numberMode = false;
                }
            });

            // 鼠标点击事件
            renderer.domElement.addEventListener('click', onCanvasClick);
        }

        // 生成号码数组
        function generateNumbers(count) {
            numbers = Array.from({ length: count }, (_, i) => i + 1);
            shuffleArray(numbers);
            currentNumber = 0;
        }

        // 随机打乱数组
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // 创建卡牌
        function createCards() {
            // 清空现有卡牌
            cardObjects.forEach(card => scene.remove(card));
            cardObjects = [];

            // 计算卡牌位置
            const cardWidth = 1;
            const cardHeight = 1.5;
            const spacing = 0.2;
            const totalWidth = (cardWidth + spacing) * availableCards.length - spacing;
            const startX = -totalWidth / 2 + cardWidth / 2;

            // 创建卡牌
            availableCards.forEach((card, index) => {
                const x = startX + index * (cardWidth + spacing);
                const cardObject = createCard(card, x, 0, 0);
                scene.add(cardObject);
                cardObjects.push(cardObject);
            });
        }

        // 创建单张卡牌
        function createCard(cardData, x, y, z) {
            const cardWidth = 1;
            const cardHeight = 1.5;
            
            // 创建卡牌几何体
            const geometry = new THREE.BoxGeometry(cardWidth, cardHeight, 0.05);
            
            // 加载卡牌背面纹理
            const textureLoader = new THREE.TextureLoader();
            const material = new THREE.MeshStandardMaterial({
                map: textureLoader.load(cardBackImageUrl)
            });
            
            // 创建卡牌网格
            const card = new THREE.Mesh(geometry, material);
            card.position.set(x, y, z);
            card.userData = {
                cardData: cardData,
                isFlipped: false,
                isSelected: false
            };
            
            return card;
        }

        // 翻转卡牌
        function flipCard(cardObject) {
            if (cardObject.userData.isFlipped) return;
            
            cardObject.userData.isFlipped = true;
            
            // 加载卡牌正面纹理
            const textureLoader = new THREE.TextureLoader();
            const frontTexture = textureLoader.load(cardObject.userData.cardData.imageUrl, () => {
                // 纹理加载完成后翻转卡牌
                gsap.to(cardObject.rotation, {
                    y: Math.PI,
                    duration: 0.5,
                    onComplete: () => {
                        // 决定正逆位
                        const isReversed = Math.random() < 0.5;
                        cardObject.userData.isReversed = isReversed;
                        
                        if (isReversed) {
                            cardObject.rotation.z = Math.PI;
                        }
                        
                        // 更新卡牌材质为正面
                        cardObject.material = new THREE.MeshStandardMaterial({
                            map: frontTexture
                        });
                        
                        // 继续翻转回正面
                        gsap.to(cardObject.rotation, {
                            y: 0,
                            duration: 0.5
                        });
                    }
                });
            });
        }

        // 鼠标点击画布
        function onCanvasClick(event) {
            if (currentMode !== 'mouse' || isDrawing) return;
            
            // 计算鼠标位置
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // 创建射线
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // 检测是否点击到卡牌
            const intersects = raycaster.intersectObjects(cardObjects);
            
            if (intersects.length > 0) {
                const clickedCard = intersects[0].object;
                selectCard(clickedCard);
            }
        }

        // 选择卡牌
        function selectCard(cardObject) {
            if (isDrawing || cardObject.userData.isSelected) return;
            
            isDrawing = true;
            selectedCard = cardObject;
            cardObject.userData.isSelected = true;
            
            // 翻转卡牌
            flipCard(cardObject);
            
            // 将卡牌移动到前面
            gsap.to(cardObject.position, {
                y: 1,
                z: -1,
                duration: 0.5,
                onComplete: () => {
                    // 显示卡牌信息
                    showCardInfo(cardObject);
                    
                    // 添加到历史记录
                    addToHistory(cardObject);
                    
                    // 从可用卡牌中移除
                    const cardIndex = availableCards.findIndex(card => card.id === cardObject.userData.cardData.id);
                    if (cardIndex !== -1) {
                        availableCards.splice(cardIndex, 1);
                    }
                    
                    // 从场景中移除卡牌并添加粒子效果
                    setTimeout(() => {
                        createCardParticles(cardObject);
                        scene.remove(cardObject);
                        
                        // 重新排列剩余卡牌
                        setTimeout(() => {
                            createCards();
                            isDrawing = false;
                            selectedCard = null;
                        }, 1000);
                    }, 2000);
                }
            });
        }

        // 显示卡牌信息
        function showCardInfo(cardObject) {
            const cardData = cardObject.userData.cardData;
            const isReversed = cardObject.userData.isReversed;
            
            let displayName = cardData.name;
            
            // 如果是数字模式或名字模式，显示相应内容
            if (numberMode && currentNumber < numbers.length) {
                displayName += ` (${numbers[currentNumber]})`;
                currentNumber++;
            } else if (nameMode && currentNameIndex < names.length) {
                displayName += ` (${names[currentNameIndex]})`;
                currentNameIndex++;
            }
            
            document.getElementById('current-card-name').textContent = displayName;
            document.getElementById('current-card-meaning').textContent = isReversed ? cardData.reversed : cardData.upright;
            
            // 添加正逆位标识
            const orientationText = isReversed ? "逆位" : "正位";
            document.getElementById('current-card-meaning').innerHTML += `<br><small>(${orientationText})</small>`;
        }

        // 添加到历史记录
        function addToHistory(cardObject) {
            const cardData = cardObject.userData.cardData;
            const isReversed = cardObject.userData.isReversed;
            
            let displayName = cardData.name;
            
            // 如果是数字模式或名字模式，显示相应内容
            if (numberMode && currentNumber > 0) {
                displayName += ` (${numbers[currentNumber - 1]})`;
            } else if (nameMode && currentNameIndex > 0) {
                displayName += ` (${names[currentNameIndex - 1]})`;
            }
            
            const historyList = document.getElementById('history-list');
            const historyItem = document.createElement('div');
            historyItem.className = 'card-history-item';
            
            const img = document.createElement('img');
            img.className = 'card-history-image';
            img.src = cardData.imageUrl;
            img.alt = cardData.name;
            
            const info = document.createElement('div');
            info.className = 'card-history-info';
            
            const name = document.createElement('div');
            name.className = 'card-history-name';
            name.textContent = displayName;
            
            const orientation = document.createElement('div');
            orientation.className = 'card-history-orientation';
            orientation.textContent = isReversed ? "逆位" : "正位";
            
            info.appendChild(name);
            info.appendChild(orientation);
            
            historyItem.appendChild(img);
            historyItem.appendChild(info);
            
            historyList.prepend(historyItem);
        }

        // 创建卡牌粒子效果
        function createCardParticles(cardObject) {
            const cardData = cardObject.userData.cardData;
            const position = cardObject.position.clone();
            
            // 加载卡牌纹理
            const textureLoader = new THREE.TextureLoader();
            const texture = textureLoader.load(cardData.imageUrl);
            
            // 创建粒子几何体
            const particleCount = 100;
            const geometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const alphas = new Float32Array(particleCount);
            const velocities = new Float32Array(particleCount * 3);
            
            // 初始化粒子
            for (let i = 0; i < particleCount; i++) {
                // 随机位置（在卡牌范围内）
                positions[i * 3] = position.x + (Math.random() - 0.5) * 1;
                positions[i * 3 + 1] = position.y + (Math.random() - 0.5) * 1.5;
                positions[i * 3 + 2] = position.z;
                
                // 随机颜色
                colors[i * 3] = Math.random();
                colors[i * 3 + 1] = Math.random();
                colors[i * 3 + 2] = Math.random();
                
                // 随机大小
                sizes[i] = Math.random() * 0.05 + 0.01;
                
                // 初始透明度
                alphas[i] = 1.0;
                
                // 随机速度（向上飘动）
                velocities[i * 3] = (Math.random() - 0.5) * 0.01;
                velocities[i * 3 + 1] = Math.random() * 0.02 + 0.01;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.01;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            
            // 创建粒子材质
            const material = new THREE.PointsMaterial({
                size: 0.05,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                vertexColors: true,
                map: texture
            });
            
            // 创建粒子系统
            const particles = new THREE.Points(geometry, material);
            scene.add(particles);
            
            // 保存粒子系统以便更新
            cardParticles.push({
                system: particles,
                velocities: velocities,
                age: 0,
                maxAge: 100
            });
        }

        // 更新粒子效果
        function updateParticles() {
            for (let i = cardParticles.length - 1; i >= 0; i--) {
                const particle = cardParticles[i];
                particle.age++;
                
                if (particle.age >= particle.maxAge) {
                    // 移除过期粒子
                    scene.remove(particle.system);
                    cardParticles.splice(i, 1);
                    continue;
                }
                
                // 更新粒子位置和透明度
                const positions = particle.system.geometry.attributes.position.array;
                const alphas = particle.system.geometry.attributes.alpha.array;
                
                for (let j = 0; j < positions.length / 3; j++) {
                    // 更新位置
                    positions[j * 3] += particle.velocities[j * 3];
                    positions[j * 3 + 1] += particle.velocities[j * 3 + 1];
                    positions[j * 3 + 2] += particle.velocities[j * 3 + 2];
                    
                    // 添加湍流噪声
                    positions[j * 3] += (Math.sin(Date.now() * 0.001 + j) * 0.002);
                    positions[j * 3 + 1] += (Math.cos(Date.now() * 0.001 + j) * 0.002);
                    
                    // 更新透明度
                    alphas[j] = 1.0 - (particle.age / particle.maxAge);
                }
                
                // 标记属性需要更新
                particle.system.geometry.attributes.position.needsUpdate = true;
                particle.system.geometry.attributes.alpha.needsUpdate = true;
            }
        }

        // 初始化手势检测
        async function initGestureDetection() {
            try {
                // 加载手势检测模型
                const model = handPoseDetection.SupportedModels.MediaPipeHands;
                const detectorConfig = {
                    runtime: 'mediapipe',
                    solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/hands',
                    modelType: 'full'
                };
                
                detector = await handPoseDetection.createDetector(model, detectorConfig);
                
                // 获取视频和画布元素
                video = document.getElementById('video');
                handCanvas = document.getElementById('hand-canvas');
                handContext = handCanvas.getContext('2d');
                
                // 调整画布大小
                handCanvas.width = video.clientWidth;
                handCanvas.height = video.clientHeight;
                
                console.log('手势检测初始化成功');
            } catch (error) {
                console.error('手势检测初始化失败:', error);
                alert('手势检测初始化失败，将自动切换到鼠标模式');
                currentMode = 'mouse';
                updateModeUI();
            }
        }

        // 切换模式
        function toggleMode() {
            if (currentMode === 'mouse') {
                // 尝试切换到手势模式
                if (detector) {
                    currentMode = 'gesture';
                    startCamera();
                } else {
                    alert('手势检测未初始化，请检查摄像头权限');
                }
            } else {
                // 切换到鼠标模式
                currentMode = 'mouse';
                stopCamera();
            }
            
            updateModeUI();
        }

        // 开始摄像头
        function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('浏览器不支持摄像头访问');
                currentMode = 'mouse';
                updateModeUI();
                return;
            }
            
            navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'user' },
                audio: false
            })
            .then(stream => {
                video.srcObject = stream;
                document.getElementById('video-container').style.display = 'block';
                detectHands();
            })
            .catch(error => {
                console.error('摄像头访问失败:', error);
                alert('摄像头访问失败，将自动切换到鼠标模式');
                currentMode = 'mouse';
                updateModeUI();
            });
        }

        // 停止摄像头
        function stopCamera() {
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                document.getElementById('video-container').style.display = 'none';
            }
        }

        // 更新模式UI
        function updateModeUI() {
            const modeSwitch = document.getElementById('mode-switch');
            if (currentMode === 'mouse') {
                modeSwitch.textContent = '切换到手势模式';
                modeSwitch.style.backgroundColor = '#4CAF50';
            } else {
                modeSwitch.textContent = '切换到鼠标模式';
                modeSwitch.style.backgroundColor = '#2196F3';
            }
        }

        // 检测手势
        async function detectHands() {
            if (currentMode !== 'gesture' || !detector || !video.readyState === 4) {
                return;
            }
            
            try {
                // 检测手部
                const hands = await detector.estimateHands(video);
                
                if (hands.length > 0) {
                    currentHand = hands[0];
                    drawHand();
                    updateHandState();
                    checkGestureInteraction();
                } else {
                    currentHand = null;
                    clearHandCanvas();
                }
            } catch (error) {
                console.error('手势检测错误:', error);
            }
            
            // 继续检测
            requestAnimationFrame(detectHands);
        }

        // 绘制手部
        function drawHand() {
            if (!currentHand || !handContext) return;
            
            clearHandCanvas();
            
            const keypoints = currentHand.keypoints;
            
            // 绘制关键点
            handContext.fillStyle = '#FF0000';
            keypoints.forEach(keypoint => {
                const { x, y } = keypoint;
                handContext.beginPath();
                handContext.arc(x, y, 5, 0, 2 * Math.PI);
                handContext.fill();
            });
            
            // 绘制连接线
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4], // 拇指
                [0, 5], [5, 6], [6, 7], [7, 8], // 食指
                [0, 9], [9, 10], [10, 11], [11, 12], // 中指
                [0, 13], [13, 14], [14, 15], [15, 16], // 无名指
                [0, 17], [17, 18], [18, 19], [19, 20] // 小指
            ];
            
            handContext.strokeStyle = '#00FF00';
            handContext.lineWidth = 2;
            
            connections.forEach(connection => {
                const [start, end] = connection;
                handContext.beginPath();
                handContext.moveTo(keypoints[start].x, keypoints[start].y);
                handContext.lineTo(keypoints[end].x, keypoints[end].y);
                handContext.stroke();
            });
        }

        // 清除手部画布
        function clearHandCanvas() {
            if (!handContext) return;
            handContext.clearRect(0, 0, handCanvas.width, handCanvas.height);
        }

        // 更新手部状态
        function updateHandState() {
            if (!currentHand) {
                currentHandState = HandState.UNKNOWN;
                return;
            }
            
            const keypoints = currentHand.keypoints;
            
            // 计算手指是否伸展
            const thumbExtended = isThumbExtended(keypoints);
            const indexExtended = isFingerExtended(keypoints, 5, 8);
            const middleExtended = isFingerExtended(keypoints, 9, 12);
            const ringExtended = isFingerExtended(keypoints, 13, 16);
            const pinkyExtended = isFingerExtended(keypoints, 17, 20);
            
            // 检测手势
            if (thumbExtended && indexExtended && !middleExtended && !ringExtended && !pinkyExtended) {
                currentHandState = HandState.POINT;
            } else if (isPinching(keypoints)) {
                currentHandState = HandState.PINCH;
            } else if (isFist(keypoints)) {
                currentHandState = HandState.FIST;
            } else if (thumbExtended && indexExtended && middleExtended && ringExtended && pinkyExtended) {
                currentHandState = HandState.OPEN;
            } else {
                currentHandState = HandState.UNKNOWN;
            }
            
            // 更新UI提示
            updateHandStateUI();
        }

        // 检查拇指是否伸展
        function isThumbExtended(keypoints) {
            const thumbTip = keypoints[4];
            const thumbIP = keypoints[3];
            const thumbMCP = keypoints[1];
            const indexMCP = keypoints[5];
            
            // 拇指伸展时，指尖通常在食指MCP的外侧
            return thumbTip.x < indexMCP.x;
        }

        // 检查手指是否伸展
        function isFingerExtended(keypoints, mcpIndex, tipIndex) {
            const mcp = keypoints[mcpIndex];
            const pip = keypoints[mcpIndex + 1];
            const dip = keypoints[mcpIndex + 2];
            const tip = keypoints[tipIndex];
            
            // 计算手指各关节的角度
            const angle1 = calculateAngle(mcp, pip, dip);
            const angle2 = calculateAngle(pip, dip, tip);
            
            // 手指伸展时，关节角度接近180度
            return angle1 > 150 && angle2 > 150;
        }

        // 计算两点之间的距离
        function calculateDistance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // 计算三点之间的角度
        function calculateAngle(p1, p2, p3) {
            const angle = Math.atan2(p3.y - p2.y, p3.x - p2.x) - 
                         Math.atan2(p1.y - p2.y, p1.x - p2.x);
            return Math.abs(angle * 180 / Math.PI);
        }

        // 检测是否捏合
        function isPinching(keypoints) {
            const thumbTip = keypoints[4];
            const indexTip = keypoints[8];
            
            // 捏合时，拇指和食指指尖距离很近
            const distance = calculateDistance(thumbTip, indexTip);
            return distance < 30;
        }

        // 检测是否握拳
        function isFist(keypoints) {
            const wrist = keypoints[0];
            const thumbTip = keypoints[4];
            const indexTip = keypoints[8];
            const middleTip = keypoints[12];
            const ringTip = keypoints[16];
            const pinkyTip = keypoints[20];
            
            // 握拳时，所有指尖都靠近手腕
            const thumbDistance = calculateDistance(wrist, thumbTip);
            const indexDistance = calculateDistance(wrist, indexTip);
            const middleDistance = calculateDistance(wrist, middleTip);
            const ringDistance = calculateDistance(wrist, ringTip);
            const pinkyDistance = calculateDistance(wrist, pinkyTip);
            
            const avgDistance = (thumbDistance + indexDistance + middleDistance + ringDistance + pinkyDistance) / 5;
            
            return avgDistance < 80;
        }

        // 更新手部状态UI
        function updateHandStateUI() {
            const infoPanel = document.getElementById('info-panel');
            
            switch (currentHandState) {
                case HandState.OPEN:
                    infoPanel.style.borderColor = '#4CAF50';
                    if (!isDrawing) {
                        document.getElementById('current-card-meaning').textContent = '手掌已张开，请选择一张卡牌';
                    }
                    break;
                case HandState.PINCH:
                    infoPanel.style.borderColor = '#FF9800';
                    if (!isDrawing) {
                        document.getElementById('current-card-meaning').textContent = '捏合手势已检测到，可以抓取卡牌';
                    }
                    break;
                case HandState.FIST:
                    infoPanel.style.borderColor = '#F44336';
                    if (!isDrawing) {
                        document.getElementById('current-card-meaning').textContent = '握拳手势已检测到，确认选择';
                    }
                    break;
                case HandState.POINT:
                    infoPanel.style.borderColor = '#2196F3';
                    if (!isDrawing) {
                        document.getElementById('current-card-meaning').textContent = '食指已伸出，可以悬停选择卡牌';
                    }
                    break;
                default:
                    infoPanel.style.borderColor = '#9E9E9E';
                    if (!isDrawing) {
                        document.getElementById('current-card-meaning').textContent = '请张开手掌进入抽卡状态';
                    }
            }
        }

        // 检查手势交互
        function checkGestureInteraction() {
            if (isDrawing || !currentHand) return;
            
            // 将手部坐标转换为Three.js场景坐标
            const normalizedX = (currentHand.keypoints[0].x / video.clientWidth) * 2 - 1;
            const normalizedY = -(currentHand.keypoints[0].y / video.clientHeight) * 2 + 1;
            
            // 创建射线
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(normalizedX, normalizedY), camera);
            
            // 检测是否指向卡牌
            const intersects = raycaster.intersectObjects(cardObjects);
            
            if (intersects.length > 0) {
                const pointedCard = intersects[0].object;
                
                // 根据手势状态进行交互
                switch (currentHandState) {
                    case HandState.OPEN:
                        // 悬停高亮
                        cardObjects.forEach(card => {
                            card.material.emissive = new THREE.Color(0x000000);
                        });
                        pointedCard.material.emissive = new THREE.Color(0x333333);
                        break;
                    case HandState.PINCH:
                        // 抓取卡牌
                        if (!pointedCard.userData.isSelected) {
                            selectCard(pointedCard);
                        }
                        break;
                    case HandState.FIST:
                        // 确认选择
                        if (!pointedCard.userData.isSelected) {
                            selectCard(pointedCard);
                        }
                        break;
                    case HandState.POINT:
                        // 悬停高亮
                        cardObjects.forEach(card => {
                            card.material.emissive = new THREE.Color(0x000000);
                        });
                        pointedCard.material.emissive = new THREE.Color(0x555555);
                        break;
                }
            } else {
                // 重置所有卡牌的高亮状态
                cardObjects.forEach(card => {
                    card.material.emissive = new THREE.Color(0x000000);
                });
            }
        }

        // 重置牌库
        function resetDeck() {
            // 清空场景中的卡牌
            cardObjects.forEach(card => scene.remove(card));
            cardObjects = [];
            
            // 重置可用卡牌
            availableCards = [...tarotCards];
            
            // 重新创建卡牌
            createCards();
            
            // 重置数字和名字索引
            currentNumber = 0;
            currentNameIndex = 0;
            
            // 如果设置了号码模式，重新生成号码
            if (numberMode) {
                const count = parseInt(document.getElementById('number-input').value);
                if (count >= 1 && count <= 100) {
                    generateNumbers(count);
                }
            }
            
            // 更新UI
            document.getElementById('current-card-name').textContent = '准备抽卡';
            document.getElementById('current-card-meaning').textContent = '请张开手掌进入抽卡状态，或使用鼠标点击卡牌';
        }

        // 清空历史
        function clearHistory() {
            document.getElementById('history-list').innerHTML = '';
        }

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新粒子效果
            updateParticles();
            
            // 渲染场景
            renderer.render(scene, camera);
        }

        // 初始化GSAP库（用于动画）
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js';
        script.onload = init;
        document.head.appendChild(script);
    </script>
</body>
</html>
