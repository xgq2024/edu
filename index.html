<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¡”ç½—ç‰ŒæŠ½å¡å°æ¸¸æˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f1f1f1;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
        }
        
        header {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin-bottom: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            color: #e0a96d;
            margin-bottom: 8px;
            font-size: 2.2rem;
            text-shadow: 0 0 10px rgba(224, 169, 109, 0.5);
        }
        
        .subtitle {
            color: #b8b8b8;
            font-size: 1rem;
        }
        
        .main-content {
            display: flex;
            flex: 1;
            gap: 15px;
        }
        
        .left-panel {
            flex: 1;
            background: rgba(30, 30, 46, 0.7);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .right-panel {
            width: 280px; /* å‡å°‘å®½åº¦ï¼ŒèŠ‚çœç©ºé—´ */
            background: rgba(30, 30, 46, 0.7);
            border-radius: 12px;
            padding: 10px; /* å‡å°‘å†…è¾¹è· */
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
        }
        
        /* ä¼˜åŒ–æŒ‰é’®æ ·å¼ï¼Œå‡å°‘ç©ºé—´å ç”¨ */
        .btn {
            padding: 8px 12px; /* å‡å°‘æŒ‰é’®å†…è¾¹è· */
            border: none;
            border-radius: 6px;
            background: #2a2a4a;
            color: #e0e0e0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            flex: 1;
            text-align: center;
            font-size: 0.9rem; /* å‡å°å­—ä½“å¤§å° */
        }
        
        /* ä¼˜åŒ–è¾“å…¥æ¡†æ ·å¼ï¼Œå‡å°‘ç©ºé—´å ç”¨ */
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 8px; /* å‡å°‘å†…è¾¹è· */
            border-radius: 6px;
            border: 1px solid #444;
            background: rgba(20, 20, 30, 0.8);
            color: #f1f1f1;
            font-size: 0.9rem; /* å‡å°å­—ä½“å¤§å° */
        }
        
        /* ä¼˜åŒ–å­¦ç”Ÿåå•è¾“å…¥æ¡†é«˜åº¦ */
        .input-group textarea {
            height: 120px; /* å‡å°‘é«˜åº¦ */
            resize: vertical;
        }
        
        /* ä¼˜åŒ–æ ‡é¢˜æ ·å¼ */
        .section-title {
            color: #e0a96d;
            margin: 10px 0 8px 0; /* å‡å°‘é—´è· */
            padding-bottom: 4px;
            border-bottom: 1px solid #444;
            font-size: 1rem; /* å‡å°å­—ä½“å¤§å° */
        }
        
        /* ä¼˜åŒ–æ§åˆ¶é¢æ¿ï¼Œå‡å°‘ç©ºé—´å ç”¨ */
        .control-panel {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            padding: 10px; /* å‡å°‘å†…è¾¹è· */
            margin-top: 10px;
        }
        
        /* ä¼˜åŒ–æ‰‹åŠ¿ä¿¡æ¯ï¼Œå‡å°‘ç©ºé—´å ç”¨ */
        .gesture-info {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 8px; /* å‡å°‘å†…è¾¹è· */
        }
        
        .gesture-item {
            text-align: center;
            flex: 1;
        }
        
        .gesture-icon {
            font-size: 1.2rem; /* å‡å°å­—ä½“å¤§å° */
            margin-bottom: 3px;
        }
        
        .gesture-label {
            font-size: 0.7rem; /* å‡å°å­—ä½“å¤§å° */
            color: #b8b8b8;
        }
        
        .viewer-container {
            flex: 1;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #0a0a15;
            border: 1px solid #444;
        }
        
        /* ä¸ŠåŠåŒºåŸŸï¼šä¸‰ä¸ªçŸ©å½¢æ¡†å®¹å™¨ */
        .card-slots-container {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            z-index: 10;
        }
        
        /* å•ä¸ªçŸ©å½¢æ¡†æ ·å¼ */
        .card-slot {
            width: 120px;
            height: 180px;
            border: 2px solid rgba(224, 169, 109, 0.6);
            border-radius: 8px;
            background: rgba(30, 30, 46, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        /* çŸ©å½¢æ¡†æ‚¬åœæ•ˆæœ */
        .card-slot:hover {
            border-color: rgba(224, 169, 109, 1);
            box-shadow: 0 0 20px rgba(224, 169, 109, 0.5);
            background: rgba(30, 30, 46, 0.5);
        }
        
        /* çŸ©å½¢æ¡†å·²æ”¾ç½®å¡ç‰Œçš„æ ·å¼ */
        .card-slot.filled {
            border-color: rgba(76, 175, 80, 0.8);
            background: rgba(30, 46, 30, 0.3);
        }
        
        /* ä¸‹åŠåŒºåŸŸï¼šå¡ç‰Œæµ®åŠ¨åŒºåŸŸ */
        .floating-cards-container {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            height: 200px;
            z-index: 10;
        }
        
        #threeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .camera-container {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 180px;
            height: 135px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #444;
            z-index: 10;
        }
        
        #cameraFeed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }
        
        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 0.9rem;
            text-align: center;
            padding: 10px;
        }
        
        .control-panel {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }
        
        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            background: #2a2a4a;
            color: #e0e0e0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            flex: 1;
            text-align: center;
        }
        
        .btn:hover {
            background: #3a3a5a;
            transform: translateY(-2px);
        }
        
        .btn.active {
            background: #e0a96d;
            color: #1a1a2e;
            box-shadow: 0 0 10px rgba(224, 169, 109, 0.5);
        }
        
        .section-title {
            color: #e0a96d;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
            font-size: 1.2rem;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #b8b8b8;
        }
        
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #444;
            background: rgba(20, 20, 30, 0.8);
            color: #f1f1f1;
            font-size: 0.95rem;
        }
        
        .input-group textarea {
            height: 100px;
            resize: vertical;
        }
        
        .status-indicator {
            display: flex;
            align-items: center;
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }
        
        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }
        
        .status-dot.active {
            background: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
        }
        
        .status-dot.inactive {
            background: #f44336;
        }
        
        .history-panel {
            flex: 1;
            overflow-y: auto;
            margin-top: 15px;
            background: rgba(20, 20, 30, 0.5);
            border-radius: 8px;
            padding: 10px;
        }
        
        .history-item {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
            border-left: 4px solid #e0a96d;
        }
        
        .history-item.upright {
            border-left-color: #4CAF50;
        }
        
        .history-item.reversed {
            border-left-color: #f44336;
        }
        
        .card-name {
            font-weight: bold;
            color: #e0a96d;
            font-size: 1.1rem;
        }
        
        .card-position {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 8px;
        }
        
        .upright .card-position {
            background: rgba(76, 175, 80, 0.2);
            color: #4CAF50;
        }
        
        .reversed .card-position {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
        }
        
        .card-meaning {
            margin-top: 8px;
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .gesture-info {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
        }
        
        .gesture-item {
            text-align: center;
            flex: 1;
        }
        
        .gesture-icon {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }
        
        .gesture-label {
            font-size: 0.8rem;
            color: #b8b8b8;
        }
        
        .particles-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        
        .instructions {
            background: rgba(40, 40, 60, 0.8);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        
        .instructions ul {
            padding-left: 20px;
            margin-top: 8px;
        }
        
        .instructions li {
            margin-bottom: 5px;
        }
        
        .btn-action {
            background: #e0a96d;
            color: #1a1a2e;
            font-weight: bold;
            padding: 12px 20px;
            margin-top: 10px;
            width: 100%;
        }
        
        .btn-action:hover {
            background: #d49c60;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                flex-direction: column;
            }
            
            .right-panel {
                width: 100%;
                height: 400px;
            }
            
            .camera-container {
                width: 150px;
                height: 113px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>å¡”ç½—ç‰ŒæŠ½å¡å°æ¸¸æˆ</h1>
            <p class="subtitle">æ‰‹åŠ¿æ§åˆ¶ / é¼ æ ‡æ§åˆ¶ | æ•°å­—æŠ½å– / å­¦ç”Ÿç‚¹å | æ­£ä½ / é€†ä½è§£è¯»</p>
        </header>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="viewer-container">
                    <canvas id="threeCanvas"></canvas>
                    
                    <!-- ä¸ŠåŠåŒºåŸŸï¼šä¸‰ä¸ªçŸ©å½¢æ¡†ï¼Œç”¨äºæ”¾ç½®æŠ½åˆ°çš„å¡”ç½—ç‰Œ -->
                    <div class="card-slots-container">
                        <div class="card-slot" id="slot1"></div>
                        <div class="card-slot" id="slot2"></div>
                        <div class="card-slot" id="slot3"></div>
                    </div>
                    
                    <!-- ä¸‹åŠåŒºåŸŸï¼šå¡ç‰Œæµ®åŠ¨åŒºåŸŸ -->
                    <div class="floating-cards-container" id="floatingCardsContainer"></div>
                    
                    <!-- æ‘„åƒå¤´å®¹å™¨ -->
                    <div class="camera-container">
                        <video id="cameraFeed" autoplay playsinline></video>
                        <div class="camera-overlay" id="cameraOverlay">
                            ç­‰å¾…æ‘„åƒå¤´æƒé™...
                        </div>
                    </div>
                    
                    <!-- ç²’å­æ•ˆæœå®¹å™¨ -->
                    <div class="particles-container" id="particlesContainer"></div>
                </div>
                
                <div class="control-panel">
                    <div class="mode-selector">
                        <button id="handModeBtn" class="btn active">æ‰‹åŠ¿æ¨¡å¼</button>
                        <button id="mouseModeBtn" class="btn">é¼ æ ‡æ¨¡å¼</button>
                    </div>
                    
                    <div class="status-indicator">
                        <div id="handStatus" class="status-dot inactive"></div>
                        <span id="handStatusText">æ‰‹åŠ¿è¯†åˆ«æœªå¯åŠ¨</span>
                    </div>
                    
                    <div class="gesture-info">
                        <div class="gesture-item">
                            <div class="gesture-icon">âœ‹</div>
                            <div class="gesture-label">å¼ å¼€æ‰‹ï¼šå‡†å¤‡æŠ½ç‰Œ</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">ğŸ‘Œ</div>
                            <div class="gesture-label">æåˆï¼šæŠ“å–å¡ç‰Œ</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">âœŠ</div>
                            <div class="gesture-label">æ¡æ‹³ï¼šç¡®è®¤æŠ½å–</div>
                        </div>
                        <div class="gesture-item">
                            <div class="gesture-icon">â˜ï¸</div>
                            <div class="gesture-label">é£ŸæŒ‡ï¼šæ‚¬åœé«˜äº®</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="section-title">æŠ½å¡æ¨¡å¼è®¾ç½®</div>
                
                <div class="input-group">
                    <label for="cardBackUrl">å¡ç‰ŒèƒŒé¢å›¾URL (å¯é€‰)</label>
                    <input type="text" id="cardBackUrl" placeholder="ç•™ç©ºä½¿ç”¨é»˜è®¤èƒŒé¢å›¾æ¡ˆ">
                </div>
                
                <div class="mode-selector" style="margin-bottom: 15px;">
                    <button id="numberModeBtn" class="btn active">æ•°å­—æŠ½å–</button>
                    <button id="nameModeBtn" class="btn">å­¦ç”Ÿç‚¹å</button>
                </div>
                
                <div id="numberModePanel">
                    <div class="input-group">
                        <label for="numberCount">æŠ½å–å·ç æ•°é‡ (1-100)</label>
                        <input type="number" id="numberCount" min="1" max="100" value="22">
                    </div>
                </div>
                
                <div id="nameModePanel" style="display: none;">
                    <div class="input-group">
                        <label for="nameList">å­¦ç”Ÿåå• (æ¯è¡Œä¸€ä¸ªåå­—)</label>
                        <textarea id="nameList" placeholder="ä¾‹å¦‚ï¼š&#10;å¼ ä¸‰&#10;æå››&#10;ç‹äº”&#10;èµµå…­"></textarea>
                    </div>
                </div>
                
                <button id="drawCardBtn" class="btn btn-action">æŠ½å–ä¸€å¼ å¡ç‰Œ</button>
                
                <div class="section-title">å½“å‰å¡ç‰Œä¿¡æ¯</div>
                <div id="currentCardInfo" style="padding: 15px; background: rgba(20, 20, 30, 0.5); border-radius: 8px; margin-bottom: 15px;">
                    <p style="text-align: center; color: #b8b8b8;">å°šæœªæŠ½å–å¡ç‰Œ</p>
                </div>
                
                <div class="section-title">æŠ½å–å†å²</div>
                <div class="history-panel" id="historyPanel">
                    <p style="text-align: center; color: #666; padding: 20px;">æš‚æ— æŠ½å–è®°å½•</p>
                </div>
                
                <div class="instructions">
                    <p><strong>ä½¿ç”¨è¯´æ˜ï¼š</strong></p>
                    <ul>
                        <li>æ‰‹åŠ¿æ¨¡å¼ä¸‹ï¼Œè¯·ç¡®ä¿æ‘„åƒå¤´å·²å¼€å¯å¹¶ä¿æŒæ‰‹éƒ¨åœ¨ç”»é¢ä¸­</li>
                        <li>é¼ æ ‡æ¨¡å¼ä¸‹ï¼Œä½¿ç”¨é¼ æ ‡ç‚¹å‡»å¡ç‰Œè¿›è¡Œäº¤äº’</li>
                        <li>æŠ½å–çš„å¡ç‰Œä¼šæ˜¾ç¤ºæ­£ä½/é€†ä½åŠå¯¹åº”å«ä¹‰</li>
                        <li>å¡ç‰Œç¡®è®¤åä¼šè½¬åŒ–ä¸ºç²’å­ç‰¹æ•ˆæ¶ˆå¤±</li>
                        <li>æŠ½å–å†å²ä¼šè®°å½•æ¯æ¬¡æŠ½åˆ°çš„å¡ç‰Œ</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å¡”ç½—ç‰Œæ•°æ® - åŒ…å«Rider-Waite-Smithç»å…¸å¡”ç½—ç‰Œå›¾ç‰‡URL
        const tarotCards = [
            { id: 0, name: "æ„šè€…", upright: "æ–°çš„å¼€å§‹, å†’é™©, è‡ªç”±", reversed: "é²è½, é£é™©, çŠ¹è±«ä¸å†³", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/RWS_Tarot_00_Fool.jpg/1024px-RWS_Tarot_00_Fool.jpg" },
            { id: 1, name: "é­”æœ¯å¸ˆ", upright: "åˆ›é€ åŠ›, æŠ€èƒ½, æ„å¿—åŠ›", reversed: "æ¬ºéª—, æœªä½¿ç”¨çš„æ½œåŠ›", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/RWS_Tarot_01_Magician.jpg/1024px-RWS_Tarot_01_Magician.jpg" },
            { id: 2, name: "å¥³ç¥­å¸", upright: "ç›´è§‰, æ½œæ„è¯†, ç¥ç§˜", reversed: "éšè—çš„æ„Ÿæƒ…, è‚¤æµ…", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/RWS_Tarot_02_High_Priestess.jpg/1024px-RWS_Tarot_02_High_Priestess.jpg" },
            { id: 3, name: "çš‡å", upright: "å…»è‚², ä¸°å¯Œ, è‡ªç„¶", reversed: "ä¾èµ–, å¿½è§†, ä¸å®‰å…¨æ„Ÿ", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/RWS_Tarot_03_Empress.jpg/1024px-RWS_Tarot_03_Empress.jpg" },
            { id: 4, name: "çš‡å¸", upright: "æƒå¨, ç»“æ„, æ§åˆ¶", reversed: "åƒµåŒ–, æ§åˆ¶æ¬², ç¼ºä¹çºªå¾‹", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/RWS_Tarot_04_Emperor.jpg/1024px-RWS_Tarot_04_Emperor.jpg" },
            { id: 5, name: "æ•™çš‡", upright: "ä¼ ç»Ÿ, ä¿¡ä»°, é“å¾·", reversed: "å›é€†, æ–°æ–¹æ³•, è‡ªç”±æ€è€ƒ", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/5/50/RWS_Tarot_05_Hierophant.jpg/1024px-RWS_Tarot_05_Hierophant.jpg" },
            { id: 6, name: "æ‹äºº", upright: "çˆ±, å’Œè°, å…³ç³»", reversed: "å†²çª, ä¸å¹³è¡¡, é”™è¯¯é€‰æ‹©", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RWS_Tarot_06_Lovers.jpg/1024px-RWS_Tarot_06_Lovers.jpg" },
            { id: 7, name: "æˆ˜è½¦", upright: "æ„å¿—åŠ›, èƒœåˆ©, è‡ªå¾‹", reversed: "ç¼ºä¹æ–¹å‘, ä¾µç•¥, å¤±æ§", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/RWS_Tarot_07_Chariot.jpg/1024px-RWS_Tarot_07_Chariot.jpg" },
            { id: 8, name: "åŠ›é‡", upright: "å‹‡æ°”, è€å¿ƒ, æ§åˆ¶", reversed: "è½¯å¼±, è‡ªæˆ‘æ€€ç–‘, æ— åŠ›æ„Ÿ", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/4/40/RWS_Tarot_08_Strength.jpg/1024px-RWS_Tarot_08_Strength.jpg" },
            { id: 9, name: "éšå£«", upright: "å†…çœ, å­¤ç‹¬, å¯»æ±‚", reversed: "å­¤ç«‹, æ‹’ç»å¸®åŠ©, éšå±…", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/RWS_Tarot_09_Hermit.jpg/1024px-RWS_Tarot_09_Hermit.jpg" },
            { id: 10, name: "å‘½è¿ä¹‹è½®", upright: "å˜åŒ–, å‘½è¿, è½¬æŠ˜ç‚¹", reversed: "åè¿æ°”, æŠµæŠ—å˜åŒ–, å»¶è¿Ÿ", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/8/82/RWS_Tarot_10_Wheel_of_Fortune.jpg/1024px-RWS_Tarot_10_Wheel_of_Fortune.jpg" },
            { id: 11, name: "æ­£ä¹‰", upright: "å…¬å¹³, çœŸç›¸, æ³•å¾‹", reversed: "ä¸å…¬æ­£, åè§, ä¸è´Ÿè´£", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/RWS_Tarot_11_Justice.jpg/1024px-RWS_Tarot_11_Justice.jpg" },
            { id: 12, name: "å€’åŠäºº", upright: "ç‰ºç‰², æ–°è§†è§’, é¡ºå…¶è‡ªç„¶", reversed: "åœæ», æ‹–å»¶, æ— è°“ç‰ºç‰²", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/RWS_Tarot_12_Hanged_Man.jpg/1024px-RWS_Tarot_12_Hanged_Man.jpg" },
            { id: 13, name: "æ­»ç¥", upright: "ç»“æŸ, è½¬å˜, æ–°ç”Ÿ", reversed: "æŠ—æ‹’å˜åŒ–, åœæ», ææƒ§", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/3/39/RWS_Tarot_13_Death.jpg/1024px-RWS_Tarot_13_Death.jpg" },
            { id: 14, name: "èŠ‚åˆ¶", upright: "å¹³è¡¡, è°ƒå’Œ, è€å¿ƒ", reversed: "ä¸å¹³è¡¡, æç«¯, ç¼ºä¹å’Œè°", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/RWS_Tarot_14_Temperance.jpg/1024px-RWS_Tarot_14_Temperance.jpg" },
            { id: 15, name: "æ¶é­”", upright: "æŸç¼š, æ¬²æœ›, ç‰©è´¨ä¸»ä¹‰", reversed: "è§£è„±, è¶…è¶Š, æ–°è®¤è¯†", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/RWS_Tarot_15_Devil.jpg/1024px-RWS_Tarot_15_Devil.jpg" },
            { id: 16, name: "å¡”", upright: "å‰§å˜, å¯ç¤º, è§‰é†’", reversed: "å®³æ€•å˜åŒ–, ç¾éš¾é¿å…", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/RWS_Tarot_16_Tower.jpg/1024px-RWS_Tarot_16_Tower.jpg" },
            { id: 17, name: "æ˜Ÿæ˜Ÿ", upright: "å¸Œæœ›, çµæ„Ÿ, å¹³é™", reversed: "ç»æœ›, å¤±æœ›, ç¼ºä¹ä¿¡å¿ƒ", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/5/52/RWS_Tarot_17_Star.jpg/1024px-RWS_Tarot_17_Star.jpg" },
            { id: 18, name: "æœˆäº®", upright: "å¹»è§‰, ææƒ§, æ½œæ„è¯†", reversed: "é‡Šæ”¾ææƒ§, çœŸç›¸æµ®ç°", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/28/RWS_Tarot_18_Moon.jpg/1024px-RWS_Tarot_18_Moon.jpg" },
            { id: 19, name: "å¤ªé˜³", upright: "æˆåŠŸ, æ´»åŠ›, ç§¯æ", reversed: "å»¶è¿ŸæˆåŠŸ, è¿‡åº¦éª„å‚²", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/RWS_Tarot_19_Sun.jpg/1024px-RWS_Tarot_19_Sun.jpg" },
            { id: 20, name: "å®¡åˆ¤", upright: "é‡ç”Ÿ, å†…åœ¨å¬å”¤, èµ¦å…", reversed: "è‡ªæˆ‘æ€€ç–‘, æ‹’ç»å¬å”¤", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f3/RWS_Tarot_20_Judgement.jpg/1024px-RWS_Tarot_20_Judgement.jpg" },
            { id: 21, name: "ä¸–ç•Œ", upright: "å®Œæˆ, æ•´åˆ, æˆå°±", reversed: "æœªå®Œæˆ, ç¼ºä¹æˆå°±æ„Ÿ", imageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/RWS_Tarot_21_World.jpg/1024px-RWS_Tarot_21_World.jpg" }
        ];
        
        // å¡ç‰ŒèƒŒé¢å›¾ç‰‡URL
        let cardBackUrl = "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/Rider-Waite_tarot_deck.jpg/320px-Rider-Waite_tarot_deck.jpg"; // é»˜è®¤èƒŒé¢å›¾
        
        // åŠ è½½ä¸­çš„å¡ç‰Œæè´¨ï¼ˆå ä½ç¬¦ï¼‰
        const loadingMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x2a2a4a,
            shininess: 30
        });
        
        // å·²åŠ è½½çš„å¡ç‰Œçº¹ç†ç¼“å­˜
        const cardTextureCache = {};
        
        // åŠ è½½å¡ç‰Œçº¹ç†
        function loadCardTexture(url, onLoad, onError) {
            // æ£€æŸ¥ç¼“å­˜
            if (cardTextureCache[url]) {
                onLoad(cardTextureCache[url]);
                return;
            }
            
            // åˆ›å»ºçº¹ç†åŠ è½½å™¨
            const textureLoader = new THREE.TextureLoader();
            
            // è®¾ç½®è·¨åŸŸåŠ è½½
            textureLoader.crossOrigin = "anonymous";
            
            // åŠ è½½çº¹ç†
            textureLoader.load(
                url,
                (texture) => {
                    // ç¼“å­˜çº¹ç†
                    cardTextureCache[url] = texture;
                    onLoad(texture);
                },
                undefined,
                (error) => {
                    console.error("åŠ è½½å¡ç‰Œçº¹ç†å¤±è´¥:", error);
                    onError(error);
                }
            );
        }

        // å…¨å±€å˜é‡
        let scene, camera, renderer, raycaster, mouse;
        let cardDeck = [];
        let remainingCards = [...tarotCards];
        let selectedCard = null;
        let isHandMode = true;
        let handDetector = null;
        let cameraStream = null;
        let isCameraActive = false;
        let currentGesture = "None";
        let particles = [];
        let particleSystem = null;
        let currentMode = "number"; // "number" æˆ– "name"
        let numberList = [];
        let nameList = [];
        let history = [];
        
        // æ–°å¢ï¼šå¡ç‰Œæ‹–æ‹½ç›¸å…³å˜é‡
        let cardSlots = []; // ä¸ŠåŠåŒºåŸŸçš„ä¸‰ä¸ªçŸ©å½¢æ¡†
        let isDragging = false;
        let draggedCard = null;

        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initThreeJS() {
            const canvas = document.getElementById('threeCanvas');
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a15);
            scene.fog = new THREE.Fog(0x0a0a15, 10, 25);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
            camera.position.set(0, 2, 10);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // å…‰çº¿æŠ•å°„å™¨ï¼ˆç”¨äºé¼ æ ‡/æ‰‹åŠ¿äº¤äº’ï¼‰
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // æ·»åŠ å…‰æº
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // æ·»åŠ è¾…åŠ©å…‰
            const backLight = new THREE.DirectionalLight(0x4466aa, 0.4);
            backLight.position.set(-5, 5, -5);
            scene.add(backLight);
            
            // åˆ›å»ºç‰Œæ¡Œ
            createTable();
            
            // åˆå§‹åˆ›å»ºç‰Œå †
            createCardDeck();
            
            // æ·»åŠ ç²’å­ç³»ç»Ÿ
            createParticleSystem();
            
            // åˆå§‹åŒ–ä¸ŠåŠåŒºåŸŸçš„ä¸‰ä¸ªçŸ©å½¢æ¡†
            initCardSlots();
            
            // æ·»åŠ çª—å£å¤§å°è°ƒæ•´ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            
            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();
        }
        
        // åˆå§‹åŒ–ä¸ŠåŠåŒºåŸŸçš„ä¸‰ä¸ªçŸ©å½¢æ¡†
        function initCardSlots() {
            // å®šä¹‰ä¸‰ä¸ªçŸ©å½¢æ¡†åœ¨3Dç©ºé—´ä¸­çš„ä½ç½®
            const slotPositions = [
                { x: -2, y: 1.5, z: 0 },
                { x: 0, y: 1.5, z: 0 },
                { x: 2, y: 1.5, z: 0 }
            ];
            
            // åˆ›å»ºä¸‰ä¸ª3DçŸ©å½¢æ¡†
            slotPositions.forEach((pos, index) => {
                const slotGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.1);
                const slotMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                
                const slot = new THREE.Mesh(slotGeometry, slotMaterial);
                slot.position.set(pos.x, pos.y, pos.z);
                slot.visible = true;
                
                // è®¾ç½®çŸ©å½¢æ¡†ç´¢å¼•ï¼Œç”¨äºåç»­è¯†åˆ«
                slot.userData.slotIndex = index;
                
                scene.add(slot);
                
                // ä¿å­˜åˆ°å…¨å±€æ•°ç»„
                cardSlots.push({
                    mesh: slot,
                    position: pos,
                    isFilled: false,
                    card: null
                });
            });
        }
        
        // å°†å¡ç‰Œæ”¾ç½®åˆ°çŸ©å½¢æ¡†ä¸­
        function placeCardInSlot(card, slot) {
            // è®¾ç½®çŸ©å½¢æ¡†ä¸ºå·²å¡«å……çŠ¶æ€
            slot.isFilled = true;
            slot.card = card;
            
            // åœæ­¢å¡ç‰Œçš„æµ®åŠ¨åŠ¨ç”»
            card.isSelected = true;
            
            // å°†å¡ç‰Œç§»åŠ¨åˆ°çŸ©å½¢æ¡†ä½ç½®
            card.group.position.set(slot.position.x, slot.position.y, slot.position.z + 0.05);
            
            // å¡ç‰Œç¿»è½¬æ•ˆæœï¼šä»èƒŒé¢ç¿»è½¬ä¸ºæ­£é¢
            flipCard(card);
            
            // ä»ç‰Œå †ä¸­ç§»é™¤è¯¥å¡ç‰Œ
            const cardIndex = cardDeck.indexOf(card);
            if (cardIndex > -1) {
                cardDeck.splice(cardIndex, 1);
            }
            
            // ç”Ÿæˆæ–°çš„å¡ç‰Œï¼Œä¿æŒç‰Œå †æ•°é‡
            setTimeout(() => {
                createNewCard();
            }, 500);
        }
        
        // å¡ç‰Œç¿»è½¬æ•ˆæœ
        function flipCard(card) {
            // ç¡®ä¿å¡ç‰Œæœ‰æ•°æ®
            if (!card.data) {
                // éšæœºä»å‰©ä½™ç‰Œåº“ä¸­é€‰æ‹©ä¸€å¼ å¡ç‰Œæ•°æ®
                if (remainingCards.length > 0) {
                    const randomIndex = Math.floor(Math.random() * remainingCards.length);
                    card.data = remainingCards[randomIndex];
                    remainingCards.splice(randomIndex, 1);
                } else {
                    // å¦‚æœç‰Œåº“å·²ç©ºï¼Œé‡ç½®ç‰Œåº“
                    remainingCards = [...tarotCards];
                    const randomIndex = Math.floor(Math.random() * remainingCards.length);
                    card.data = remainingCards[randomIndex];
                    remainingCards.splice(randomIndex, 1);
                }
            }
            
            // ç¿»è½¬å¡ç‰Œï¼Œæ˜¾ç¤ºæ­£é¢
            card.isFaceUp = true;
            
            // æ›´æ–°å¡ç‰Œæè´¨ï¼Œæ˜¾ç¤ºæ­£é¢å›¾ç‰‡
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ä½¿ç”¨Three.jsçš„æè´¨å±æ€§æ¥æ¨¡æ‹Ÿç¿»è½¬æ•ˆæœ
            // å®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„åŠ¨ç”»
            card.group.rotation.y = 0; // æ­£é¢æœä¸Š
            
            // æ ¹æ®æ¨¡å¼æ˜¾ç¤ºå†…å®¹ï¼ˆå­¦ç”Ÿå§“åæˆ–å·ç ï¼‰
            let displayText = card.data.name;
            if (currentMode === "number" && numberList.length > 0) {
                const numIndex = Math.floor(Math.random() * numberList.length);
                displayText = `#${numberList[numIndex]}`;
                numberList.splice(numIndex, 1);
            } else if (currentMode === "name" && nameList.length > 0) {
                const nameIndex = Math.floor(Math.random() * nameList.length);
                displayText = nameList[nameIndex];
                nameList.splice(nameIndex, 1);
            }
            
            // æ›´æ–°å¡ç‰Œæ˜¾ç¤ºçš„æ–‡å­—
            // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬ç®€åŒ–å¤„ç†ï¼Œå®é™…é¡¹ç›®ä¸­å¯ä»¥æ›´æ–°Spriteæˆ–é‡æ–°åˆ›å»ºæè´¨
            card.displayText = displayText;
        }
        
        // åˆ›å»ºç‰Œæ¡Œ
        function createTable() {
            const tableGeometry = new THREE.BoxGeometry(12, 0.5, 8);
            const tableMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x2a1e0f,
                shininess: 30
            });
            const table = new THREE.Mesh(tableGeometry, tableMaterial);
            table.position.set(0, -1, 0);
            table.receiveShadow = true;
            scene.add(table);
            
            // æ·»åŠ æ¡Œå¸ƒçº¹ç†
            const clothGeometry = new THREE.PlaneGeometry(11.5, 7.5);
            const clothMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x1a0f2a,
                side: THREE.DoubleSide
            });
            const cloth = new THREE.Mesh(clothGeometry, clothMaterial);
            cloth.rotation.x = Math.PI / 2;
            cloth.position.set(0, -0.24, 0);
            scene.add(cloth);
        }
        
        // åˆ›å»ºå¡ç‰Œ
        function createCard(width, height, depth, isFront = true, cardData = null) {
            const cardGroup = new THREE.Group();
            
            // å¡ç‰Œä¸»ä½“
            const cardGeometry = new THREE.BoxGeometry(width, height, depth);
            
            // åˆ›å»ºå¡ç‰Œæè´¨
            let cardMaterial;
            if (isFront && cardData) {
                // æ­£é¢ - ä½¿ç”¨é«˜æ¸…å¡”ç½—ç‰Œå›¾ç‰‡
                cardMaterial = new THREE.MeshPhongMaterial({ 
                    map: null, // åˆå§‹ä¸ºnullï¼Œç¨ååŠ è½½
                    color: 0x2a2a4a, // åŠ è½½æœŸé—´çš„å ä½é¢œè‰²
                    shininess: 60
                });
                
                // åŠ è½½å¡ç‰Œæ­£é¢å›¾ç‰‡
                loadCardTexture(cardData.imageUrl, 
                    (texture) => {
                        cardMaterial.map = texture;
                        cardMaterial.needsUpdate = true;
                    },
                    (error) => {
                        // åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨å ä½é¢œè‰²
                        cardMaterial.color.setHex(0x3a3a5a);
                        cardMaterial.needsUpdate = true;
                    }
                );
            } else {
                // èƒŒé¢ - ä½¿ç”¨é€šç”¨èƒŒé¢å›¾ç‰‡
                cardMaterial = new THREE.MeshPhongMaterial({ 
                    map: null, // åˆå§‹ä¸ºnullï¼Œç¨ååŠ è½½
                    color: 0x1a1a2e, // åŠ è½½æœŸé—´çš„å ä½é¢œè‰²
                    shininess: 50
                });
                
                // åŠ è½½å¡ç‰ŒèƒŒé¢å›¾ç‰‡
                const backUrl = document.getElementById('cardBackUrl').value || cardBackUrl;
                loadCardTexture(backUrl, 
                    (texture) => {
                        cardMaterial.map = texture;
                        cardMaterial.needsUpdate = true;
                    },
                    (error) => {
                        // åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é¢œè‰²å’Œå›¾æ¡ˆ
                        cardMaterial.color.setHex(0x1a1a2e);
                        cardMaterial.needsUpdate = true;
                        // æ·»åŠ ç®€å•çš„èƒŒé¢å›¾æ¡ˆ
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        const context = canvas.getContext('2d');
                        context.fillStyle = '#1a1a2e';
                        context.fillRect(0, 0, 256, 256);
                        context.strokeStyle = '#e0a96d';
                        context.lineWidth = 4;
                        context.beginPath();
                        context.arc(128, 128, 100, 0, Math.PI * 2);
                        context.stroke();
                        const texture = new THREE.CanvasTexture(canvas);
                        cardMaterial.map = texture;
                        cardMaterial.needsUpdate = true;
                    }
                );
            }
            
            const cardMesh = new THREE.Mesh(cardGeometry, cardMaterial);
            cardMesh.castShadow = true;
            cardMesh.receiveShadow = true;
            cardGroup.add(cardMesh);
            
            // ä¸ºå¡ç‰Œæ·»åŠ è¾¹æ¡†
            const edgeGeometry = new THREE.BoxGeometry(width + 0.02, height + 0.02, depth + 0.01);
            const edgeMaterial = new THREE.MeshBasicMaterial({ 
                color: isFront ? 0x222222 : 0xe0a96d,
                side: THREE.BackSide
            });
            const edgeMesh = new THREE.Mesh(edgeGeometry, edgeMaterial);
            cardGroup.add(edgeMesh);
            
            // æ·»åŠ å¡ç‰Œæ–‡å­—
            if (isFront && cardData) {
                addCardText(cardGroup, cardData, width, height);
            }
            
            return cardGroup;
        }
        
        // æ·»åŠ å¡ç‰Œæ–‡å­—
        function addCardText(cardGroup, cardData, width, height) {
            // ä½¿ç”¨CSS3Dæ¸²æŸ“å™¨æ›¿ä»£ï¼Œç®€åŒ–å®ç°
            // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨Three.jsçš„Spriteæ¥æ¨¡æ‹Ÿæ–‡å­—
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // ç»˜åˆ¶å¡ç‰Œåç§°èƒŒæ™¯
            context.fillStyle = 'rgba(20, 20, 30, 0.8)';
            context.fillRect(0, 0, 256, 256);
            
            // ç»˜åˆ¶å¡ç‰Œåç§°
            context.font = 'bold 24px Arial';
            context.fillStyle = '#e0a96d';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // æ ¹æ®æ¨¡å¼æ˜¾ç¤ºå†…å®¹
            let displayText = cardData.name;
            if (currentMode === "number" && numberList.length > 0) {
                displayText = `#${cardData.displayNumber || cardData.id + 1}`;
            } else if (currentMode === "name" && nameList.length > 0) {
                displayText = cardData.displayName || cardData.name;
            }
            
            // å¦‚æœæ–‡å­—å¤ªé•¿ï¼Œæ¢è¡Œæ˜¾ç¤º
            if (displayText.length > 6) {
                const mid = Math.floor(displayText.length / 2);
                const line1 = displayText.substring(0, mid);
                const line2 = displayText.substring(mid);
                context.fillText(line1, 128, 110);
                context.fillText(line2, 128, 146);
            } else {
                context.fillText(displayText, 128, 128);
            }
            
            // åˆ›å»ºçº¹ç†
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(width * 0.8, height * 0.8, 1);
            sprite.position.set(0, 0, 0.26);
            cardGroup.add(sprite);
        }
        
        // æ·»åŠ å¡ç‰ŒèƒŒé¢å›¾æ¡ˆ
        function addCardBackPattern(cardGroup, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // ç»˜åˆ¶èƒŒé¢å›¾æ¡ˆ
            context.fillStyle = '#1a1a2e';
            context.fillRect(0, 0, 256, 256);
            
            // ç»˜åˆ¶ç¥ç§˜ç¬¦å·
            context.strokeStyle = '#e0a96d';
            context.lineWidth = 4;
            
            // å¤–åœ†
            context.beginPath();
            context.arc(128, 128, 100, 0, Math.PI * 2);
            context.stroke();
            
            // å†…åœ†
            context.beginPath();
            context.arc(128, 128, 70, 0, Math.PI * 2);
            context.stroke();
            
            // å…­èŠ’æ˜Ÿ
            drawStar(context, 128, 128, 60, 6);
            context.stroke();
            
            // åˆ›å»ºçº¹ç†
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.scale.set(width * 0.8, height * 0.8, 1);
            sprite.position.set(0, 0, 0.26);
            cardGroup.add(sprite);
        }
        
        // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
        function drawStar(ctx, cx, cy, radius, points) {
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (i * Math.PI) / points;
                const r = i % 2 === 0 ? radius : radius * 0.5;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
        }
        
        // åˆ›å»ºç‰Œå †
        function createCardDeck() {
            // æ¸…ç©ºç°æœ‰ç‰Œå †
            cardDeck.forEach(card => scene.remove(card.group));
            cardDeck = [];
            
            // åˆ›å»ºæ–°ç‰Œå †
            const cardWidth = 0.6;
            const cardHeight = 1.0;
            const cardDepth = 0.02;
            const cardCount = 5; // å¡ç‰Œæ•°é‡
            const spacing = 1.2; // å¡ç‰Œé—´è·
            
            // è®¡ç®—èµ·å§‹ä½ç½®ï¼Œä½¿å¡ç‰Œå±…ä¸­æ’åˆ—
            const startX = -((cardCount - 1) * spacing) / 2;
            
            // åˆ›å»ºç‰Œå †ï¼ˆèƒŒé¢æœä¸Šï¼Œæ¨ªå‘æ’åˆ—ï¼‰
            for (let i = 0; i < cardCount; i++) {
                const card = createCard(cardWidth, cardHeight, cardDepth, false);
                
                // è®¾ç½®ä½ç½®ï¼šæ¨ªå‘å±…ä¸­æ’åˆ—ï¼Œä½äºä¸‹åŠåŒºåŸŸ
                card.position.set(startX + i * spacing, -1, 0);
                card.rotation.y = Math.PI; // èƒŒé¢æœä¸Š
                
                scene.add(card);
                
                cardDeck.push({
                    group: card,
                    isFaceUp: false,
                    data: null,
                    isSelected: false,
                    isReversed: false,
                    originalX: startX + i * spacing, // è®°å½•åŸå§‹Xä½ç½®ï¼Œç”¨äºæµ®åŠ¨åŠ¨ç”»
                    originalY: -1, // è®°å½•åŸå§‹Yä½ç½®
                    floatOffset: Math.random() * Math.PI * 2 // æµ®åŠ¨åç§»é‡ï¼Œç”¨äºåˆ›é€ é”™è½æœ‰è‡´çš„æ•ˆæœ
                });
            }
        }
        
        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            const particleCount = 2000;
            
            // åˆ›å»ºç²’å­å±æ€§æ•°ç»„
            const positions = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);
            const alphas = new Float32Array(particleCount);
            
            // åˆå§‹åŒ–ç²’å­ä½ç½®
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = 0; // x
                positions[i * 3 + 1] = 0; // y
                positions[i * 3 + 2] = 0; // z
                sizes[i] = Math.random() * 0.05 + 0.02; // éšæœºå¤§å°
                alphas[i] = 0; // åˆå§‹é€æ˜åº¦ä¸º0
            }
            
            // åˆ›å»ºå‡ ä½•ä½“
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
            
            // åˆ›å»ºæè´¨
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(0xe0a96d) }
                },
                vertexShader: `
                    attribute float size;
                    attribute float alpha;
                    varying float vAlpha;
                    void main() {
                        vAlpha = alpha;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying float vAlpha;
                    void main() {
                        // åœ†å½¢ç²’å­
                        vec2 p = gl_PointCoord - vec2(0.5);
                        float distance = length(p);
                        if (distance > 0.5) discard;
                        gl_FragColor = vec4(color, vAlpha * (1.0 - distance * 2.0));
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            // åˆå§‹åŒ–ç²’å­æ•°æ®
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: 0, y: 0, z: 0,
                    vx: 0, vy: 0, vz: 0,
                    life: 0,
                    maxLife: 0,
                    size: sizes[i],
                    alpha: 0,
                    active: false
                });
            }
        }
        
        // å‘å°„ç²’å­ï¼ˆå¡ç‰Œæ¶ˆå¤±æ•ˆæœï¼‰
        function emitParticles(position, count = 500) {
            const positions = particleSystem.geometry.attributes.position.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            const alphas = particleSystem.geometry.attributes.alpha.array;
            
            for (let i = 0; i < particles.length && count > 0; i++) {
                if (!particles[i].active) {
                    particles[i].active = true;
                    particles[i].life = particles[i].maxLife = Math.random() * 120 + 60; // 60-180å¸§å¯¿å‘½
                    particles[i].x = position.x;
                    particles[i].y = position.y;
                    particles[i].z = position.z;
                    
                    // éšæœºé€Ÿåº¦ï¼ˆå‘ä¸Šé£˜æ•£ï¼‰
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 0.05 + 0.02;
                    particles[i].vx = Math.cos(angle) * speed * 0.3;
                    particles[i].vy = Math.random() * 0.15 + 0.1; // æ›´å¼ºçš„å‘ä¸Šé€Ÿåº¦
                    particles[i].vz = Math.sin(angle) * speed * 0.3;
                    
                    // åˆå§‹é€æ˜åº¦ä¸º1
                    particles[i].alpha = 1.0;
                    
                    // æ›´æ–°ç²’å­å±æ€§æ•°ç»„
                    positions[i * 3] = particles[i].x;
                    positions[i * 3 + 1] = particles[i].y;
                    positions[i * 3 + 2] = particles[i].z;
                    sizes[i] = particles[i].size;
                    alphas[i] = particles[i].alpha;
                    
                    count--;
                }
            }
            
            // æ ‡è®°éœ€è¦æ›´æ–°çš„å±æ€§
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
            particleSystem.geometry.attributes.alpha.needsUpdate = true;
        }
        
        // æ›´æ–°ç²’å­ç³»ç»Ÿ
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const alphas = particleSystem.geometry.attributes.alpha.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            let activeParticles = 0;
            
            for (let i = 0; i < particles.length; i++) {
                if (particles[i].active) {
                    particles[i].life--;
                    
                    if (particles[i].life > 0) {
                        // è®¡ç®—ç”Ÿå‘½å‘¨æœŸç™¾åˆ†æ¯”
                        const lifePercent = particles[i].life / particles[i].maxLife;
                        
                        // æ›´æ–°ä½ç½®ï¼Œæ·»åŠ æ¹æµå™ªå£°
                        const turbulence = 0.005 * (1 - lifePercent); // æ¹æµå¼ºåº¦éšç”Ÿå‘½å‘¨æœŸè¡°å‡
                        particles[i].x += particles[i].vx + (Math.random() - 0.5) * turbulence;
                        particles[i].y += particles[i].vy + (Math.random() - 0.5) * turbulence * 0.5;
                        particles[i].z += particles[i].vz + (Math.random() - 0.5) * turbulence;
                        
                        // é€æ˜åº¦éšç”Ÿå‘½å‘¨æœŸè¡°å‡
                        particles[i].alpha = lifePercent;
                        
                        // æ›´æ–°ç²’å­å±æ€§æ•°ç»„
                        positions[i * 3] = particles[i].x;
                        positions[i * 3 + 1] = particles[i].y;
                        positions[i * 3 + 2] = particles[i].z;
                        alphas[i] = particles[i].alpha;
                        sizes[i] = particles[i].size * (0.5 + lifePercent * 0.5); // å¤§å°éšç”Ÿå‘½å‘¨æœŸç•¥å¾®å‡å°
                        
                        activeParticles++;
                    } else {
                        // ç²’å­å¯¿å‘½ç»“æŸï¼Œé‡ç½®çŠ¶æ€
                        particles[i].active = false;
                        particles[i].alpha = 0;
                        positions[i * 3] = 0;
                        positions[i * 3 + 1] = 0;
                        positions[i * 3 + 2] = 0;
                        alphas[i] = 0;
                        sizes[i] = 0;
                    }
                }
            }
            
            // æ ‡è®°éœ€è¦æ›´æ–°çš„å±æ€§
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.alpha.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
        }
        
        // åˆå§‹åŒ–MediaPipeæ‰‹åŠ¿è¯†åˆ«
        async function initHandTracking() {
            const videoElement = document.getElementById('cameraFeed');
            const canvasElement = document.createElement('canvas');
            const canvasCtx = canvasElement.getContext('2d');
            
            // é…ç½®MediaPipe Hands
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onHandResults);
            
            // å¯åŠ¨æ‘„åƒå¤´
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 }, 
                        height: { ideal: 480 },
                        facingMode: "user"
                    } 
                });
                
                videoElement.srcObject = cameraStream;
                isCameraActive = true;
                document.getElementById('cameraOverlay').style.display = 'none';
                
                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                document.getElementById('handStatus').className = 'status-dot active';
                document.getElementById('handStatusText').textContent = 'æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨';
                
                // å¼€å§‹å¤„ç†è§†é¢‘å¸§
                // æ£€æŸ¥Cameraç±»æ˜¯å¦å¯ç”¨
                if (window.Camera) {
                    const camera = new Camera(videoElement, {
                        onFrame: async () => {
                            await hands.send({image: videoElement});
                        },
                        width: 640,
                        height: 480
                    });
                    
                    camera.start();
                    handDetector = hands;
                } else {
                    // å›é€€åˆ°requestAnimationFrameå¾ªç¯
                    async function processFrame() {
                        if (isCameraActive) {
                            await hands.send({image: videoElement});
                            requestAnimationFrame(processFrame);
                        }
                    }
                    processFrame();
                }
                
            } catch (err) {
                console.error("æ‘„åƒå¤´è®¿é—®å¤±è´¥:", err);
                document.getElementById('cameraOverlay').textContent = 'æ‘„åƒå¤´è®¿é—®å¤±è´¥ï¼Œå·²åˆ‡æ¢åˆ°é¼ æ ‡æ¨¡å¼';
                switchToMouseMode();
            }
        }
        
        // å¤„ç†æ‰‹åŠ¿è¯†åˆ«ç»“æœ
        function onHandResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                currentGesture = "None";
                return;
            }
            
            const landmarks = results.multiHandLandmarks[0];
            
            // è®¡ç®—æ‰‹åŠ¿
            const gesture = detectGesture(landmarks);
            currentGesture = gesture;
            
            // å¤„ç†æ‰‹åŠ¿äº¤äº’
            if (isHandMode) {
                handleGestureInteraction(landmarks, gesture);
            }
        }
        
        // æ£€æµ‹æ‰‹åŠ¿ç±»å‹
        function detectGesture(landmarks) {
            // ç®€åŒ–çš„æ‰‹åŠ¿æ£€æµ‹é€»è¾‘
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];
            
            // è®¡ç®—æŒ‡å°–ä¸æŒå¿ƒçš„è·ç¦»
            const indexToWrist = distance(thumbTip, wrist);
            const thumbToIndex = distance(thumbTip, indexTip);
            
            // æ£€æµ‹æåˆæ‰‹åŠ¿
            if (thumbToIndex < 0.05) {
                return "PINCH";
            }
            
            // æ£€æµ‹æ¡æ‹³æ‰‹åŠ¿
            let allFingersClosed = true;
            for (let i = 6; i <= 20; i += 4) {
                const fingerTip = landmarks[i];
                const fingerPip = landmarks[i-2];
                if (distance(fingerTip, wrist) > distance(fingerPip, wrist) * 0.9) {
                    allFingersClosed = false;
                    break;
                }
            }
            
            if (allFingersClosed) {
                return "FIST";
            }
            
            // æ£€æµ‹é£ŸæŒ‡æŒ‡å‘
            const indexExtended = distance(indexTip, wrist) > distance(landmarks[5], wrist) * 1.2;
            const otherFingersClosed = 
                distance(middleTip, wrist) < distance(landmarks[9], wrist) * 0.9 &&
                distance(ringTip, wrist) < distance(landmarks[13], wrist) * 0.9 &&
                distance(pinkyTip, wrist) < distance(landmarks[17], wrist) * 0.9;
                
            if (indexExtended && otherFingersClosed) {
                return "POINT";
            }
            
            // æ£€æµ‹å¼ å¼€æ‰‹æŒ
            let allFingersExtended = true;
            for (let i = 8; i <= 20; i += 4) {
                const fingerTip = landmarks[i];
                const fingerPip = landmarks[i-2];
                if (distance(fingerTip, wrist) < distance(fingerPip, wrist) * 1.1) {
                    allFingersExtended = false;
                    break;
                }
            }
            
            if (allFingersExtended) {
                return "OPEN";
            }
            
            return "None";
        }
        
        // è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
        function distance(point1, point2) {
            const dx = point1.x - point2.x;
            const dy = point1.y - point2.y;
            const dz = point1.z - point2.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }
        
        // å¤„ç†æ‰‹åŠ¿äº¤äº’
        function handleGestureInteraction(landmarks, gesture) {
            // å°†æ‰‹åŠ¿åæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
            const indexTip = landmarks[8];
            
            // å°†æ‰‹åŠ¿åæ ‡æ˜ å°„åˆ°3Dåœºæ™¯ä¸­
            // landmarksåæ ‡èŒƒå›´ä¸º[0, 1]ï¼Œéœ€è¦è½¬æ¢ä¸ºæ ‡å‡†åŒ–è®¾å¤‡åæ ‡[-1, 1]
            mouse.x = (indexTip.x * 2) - 1;
            mouse.y = -(indexTip.y * 2) + 1;
            
            // æ›´æ–°å°„çº¿æŠ•å°„å™¨
            raycaster.setFromCamera(mouse, camera);
            
            if (gesture === "OPEN") {
                // å¼ å¼€æ‰‹æŒï¼šé‡Šæ”¾æ‹–æ‹½ï¼Œæ”¾ç½®å¡ç‰Œ
                if (isDragging && selectedCard) {
                    // æ£€æŸ¥å¡ç‰Œæ˜¯å¦åœ¨æŸä¸ªçŸ©å½¢æ¡†ä¸­
                    let placedInSlot = false;
                    
                    // æ£€æŸ¥æ˜¯å¦å‘½ä¸­ä»»ä½•çŸ©å½¢æ¡†
                    const slotIntersects = raycaster.intersectObjects(cardSlots.map(slot => slot.mesh));
                    if (slotIntersects.length > 0) {
                        // è·å–å‘½ä¸­çš„çŸ©å½¢æ¡†ç´¢å¼•
                        const slotIndex = slotIntersects[0].object.userData.slotIndex;
                        const targetSlot = cardSlots[slotIndex];
                        
                        // å¦‚æœçŸ©å½¢æ¡†ä¸ºç©ºï¼Œåˆ™æ”¾ç½®å¡ç‰Œ
                        if (!targetSlot.isFilled) {
                            // å°†å¡ç‰Œæ”¾ç½®åˆ°çŸ©å½¢æ¡†ä¸­
                            placeCardInSlot(selectedCard, targetSlot);
                            placedInSlot = true;
                            document.getElementById('handStatusText').textContent = 'å¡ç‰Œå·²æ”¾ç½®åˆ°çŸ©å½¢æ¡†';
                        }
                    }
                    
                    // å¦‚æœæ²¡æœ‰æ”¾ç½®åˆ°çŸ©å½¢æ¡†ä¸­ï¼Œå°†å¡ç‰Œæ”¾å›åŸä½
                    if (!placedInSlot) {
                        selectedCard.group.position.set(selectedCard.originalX, selectedCard.originalY, 0);
                        selectedCard.isSelected = false;
                        selectedCard.group.children[0].material.emissive = new THREE.Color(0x000000);
                        document.getElementById('handStatusText').textContent = 'å¡ç‰Œå·²æ”¾å›åŸä½';
                    }
                    
                    // ç»“æŸæ‹–æ‹½çŠ¶æ€
                    isDragging = false;
                    selectedCard = null;
                } else {
                    // é‡ç½®æ‰€æœ‰å¡ç‰Œçš„æƒ¯æ€§è¿åŠ¨
                    cardDeck.forEach(card => {
                        card.isMoving = false;
                    });
                    // é«˜äº®æ‰€æœ‰å¯æŠ½å–çš„å¡ç‰Œ
                    highlightCards();
                    // æ›´æ–°çŠ¶æ€æ–‡æœ¬
                    document.getElementById('handStatusText').textContent = 'è¿›å…¥å¾…æŠ½ç‰ŒçŠ¶æ€';
                }
            } else if (gesture === "PINCH") {
                // æåˆï¼šæŠ“å–/æ‹–æ‹½å¡ç‰Œ
                if (selectedCard === null) {
                    // å°è¯•é€‰æ‹©å°„çº¿å‘½ä¸­çš„å¡ç‰Œ
                    const intersects = raycaster.intersectObjects(cardDeck.map(card => card.group));
                    if (intersects.length > 0) {
                        const clickedCard = cardDeck.find(card => card.group === intersects[0].object.parent);
                        if (clickedCard && !clickedCard.isSelected) {
                            selectCard(clickedCard);
                            isDragging = true;
                            document.getElementById('handStatusText').textContent = 'å·²æŠ“å–å¡ç‰Œï¼Œå¼€å§‹æ‹–æ‹½';
                        }
                    }
                } else {
                    // æ‹–æ‹½å¡ç‰Œè·Ÿéšæ‰‹åŠ¿ç§»åŠ¨
                    if (isDragging) {
                        // å°†æ‰‹åŠ¿ä½ç½®è½¬æ¢ä¸º3Dç©ºé—´ä¸­çš„ä½ç½®
                        const raycastResults = raycaster.intersectObjects([scene.children.find(child => child.name === 'table') || scene.children[0]]);
                        if (raycastResults.length > 0) {
                            const targetPosition = raycastResults[0].point;
                            // é™åˆ¶å¡ç‰Œçš„Yåæ ‡ï¼Œä½¿å…¶åœ¨åˆé€‚çš„é«˜åº¦
                            targetPosition.y = Math.max(-1, Math.min(2, targetPosition.y));
                            selectedCard.group.position.copy(targetPosition);
                        }
                    }
                }
            } else if (gesture === "FIST") {
                // æ¡æ‹³ï¼šç¡®è®¤æŠ½ç‰Œå¹¶é”å®šç»“æœ
                if (selectedCard !== null) {
                    confirmCardSelection();
                    document.getElementById('handStatusText').textContent = 'å·²ç¡®è®¤æŠ½ç‰Œ';
                }
            } else if (gesture === "POINT") {
                // é£ŸæŒ‡ï¼šæ‚¬åœé«˜äº®/åœæ­¢æƒ¯æ€§
                // åœæ­¢æ‰€æœ‰å¡ç‰Œçš„æƒ¯æ€§è¿åŠ¨
                cardDeck.forEach(card => {
                    card.isMoving = false;
                });
                // é«˜äº®å°„çº¿å‘½ä¸­çš„å¡ç‰Œ
                const intersects = raycaster.intersectObjects(cardDeck.map(card => card.group));
                if (intersects.length > 0) {
                    const hoveredCard = cardDeck.find(card => card.group === intersects[0].object.parent);
                    if (hoveredCard && !hoveredCard.isSelected) {
                        // é‡ç½®æ‰€æœ‰å¡ç‰Œçš„é«˜äº®
                        cardDeck.forEach(card => {
                            if (!card.isSelected) {
                                card.group.children[0].material.emissive = new THREE.Color(0x000000);
                            }
                        });
                        // é«˜äº®å½“å‰æ‚¬åœçš„å¡ç‰Œ
                        hoveredCard.group.children[0].material.emissive = new THREE.Color(0x333333);
                        document.getElementById('handStatusText').textContent = 'æ‚¬åœé«˜äº®å¡ç‰Œ';
                    }
                }
            } else {
                // å…¶ä»–æ‰‹åŠ¿ï¼šé‡ç½®çŠ¶æ€
                document.getElementById('handStatusText').textContent = 'æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨';
            }
        }
        
        // é€šè¿‡å°„çº¿æŠ•å°„é€‰æ‹©å¡ç‰Œ
        function selectCardWithRaycast(x, y) {
            // å°†æ‰‹åŠ¿åæ ‡è½¬æ¢ä¸ºæ ‡å‡†åŒ–è®¾å¤‡åæ ‡
            mouse.x = (x * 2) - 1;
            mouse.y = -(y * 2) + 1;
            
            // æ›´æ–°å°„çº¿æŠ•å°„å™¨
            raycaster.setFromCamera(mouse, camera);
            
            // è®¡ç®—ä¸å¡ç‰Œçš„äº¤ç‚¹
            const intersects = raycaster.intersectObjects(cardDeck.map(card => card.group));
            
            if (intersects.length > 0) {
                const clickedCard = cardDeck.find(card => card.group === intersects[0].object.parent);
                if (clickedCard && !clickedCard.isSelected) {
                    selectCard(clickedCard);
                }
            }
        }
        
        // é«˜äº®å¡ç‰Œï¼ˆæ‚¬åœæ•ˆæœï¼‰
        function highlightCards() {
            // å®ç°æ‚¬åœé«˜äº®é€»è¾‘
            cardDeck.forEach(card => {
                if (!card.isSelected) {
                    // é‡ç½®æ‰€æœ‰æœªé€‰ä¸­å¡ç‰Œçš„é«˜äº®
                    card.group.children[0].material.emissive = new THREE.Color(0x000000);
                }
            });
        }
        
        // é€‰æ‹©å¡ç‰Œ
        function selectCard(card) {
            // å–æ¶ˆä¹‹å‰çš„é€‰æ‹©
            if (selectedCard) {
                selectedCard.isSelected = false;
                selectedCard.group.children[0].material.emissive = new THREE.Color(0x000000);
            }
            
            // é€‰æ‹©æ–°å¡ç‰Œ
            selectedCard = card;
            selectedCard.isSelected = true;
            selectedCard.group.children[0].material.emissive = new THREE.Color(0xe0a96d);
            
            // å°†å¡ç‰Œç§»åŠ¨åˆ°é€‰ä¸­ä½ç½®
            selectedCard.originalPosition = selectedCard.group.position.clone();
            selectedCard.originalRotation = selectedCard.group.rotation.clone();
        }
        
        // å°†é€‰ä¸­çš„å¡ç‰Œç§»åŠ¨åˆ°é•œå¤´å‰
        function moveSelectedCardToFront() {
            if (!selectedCard) return;
            
            // ç›®æ ‡ä½ç½®ï¼šé•œå¤´å‰
            const targetPosition = new THREE.Vector3(0, 1, 5);
            selectedCard.group.position.lerp(targetPosition, 0.1);
            
            // ä½¿å¡ç‰Œé¢å‘ç›¸æœº
            selectedCard.group.lookAt(camera.position);
        }
        
        // ç¡®è®¤å¡ç‰Œé€‰æ‹©
        function confirmCardSelection() {
            if (!selectedCard) return;
            
            // æ˜¾ç¤ºå¡ç‰Œä¿¡æ¯
            displayCardInfo(selectedCard);
            
            // æ·»åŠ åˆ°å†å²è®°å½•
            addToHistory(selectedCard);
            
            // ç²’å­æ•ˆæœ
            emitParticles(selectedCard.group.position);
            
            // ä»åœºæ™¯ä¸­ç§»é™¤å¡ç‰Œ
            scene.remove(selectedCard.group);
            
            // ä»ç‰Œå †ä¸­ç§»é™¤
            const index = cardDeck.indexOf(selectedCard);
            if (index > -1) {
                cardDeck.splice(index, 1);
            }
            
            // ä»å‰©ä½™ç‰Œåº“ä¸­ç§»é™¤
            if (selectedCard.data) {
                const cardIndex = remainingCards.findIndex(card => card.id === selectedCard.data.id);
                if (cardIndex > -1) {
                    remainingCards.splice(cardIndex, 1);
                }
            }
            
            // é‡ç½®é€‰æ‹©
            selectedCard = null;
            
            // åˆ›å»ºæ–°å¡ç‰Œ
            createNewCard();
        }
        
        // æ˜¾ç¤ºå¡ç‰Œä¿¡æ¯
        function displayCardInfo(card) {
            const cardInfoDiv = document.getElementById('currentCardInfo');
            
            let displayText = card.data ? card.data.name : "æœªçŸ¥å¡ç‰Œ";
            let meaning = "æœªçŸ¥å«ä¹‰";
            
            if (card.data) {
                if (currentMode === "number" && numberList.length > 0) {
                    displayText = `å·ç : ${card.displayNumber || card.data.id + 1}`;
                } else if (currentMode === "name" && nameList.length > 0) {
                    displayText = `å­¦ç”Ÿ: ${card.displayName || card.data.name}`;
                } else {
                    displayText = card.data.name;
                }
                
                meaning = card.isReversed ? card.data.reversed : card.data.upright;
            }
            
            cardInfoDiv.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <span class="card-name">${displayText}</span>
                    <span class="card-position ${card.isReversed ? 'reversed' : 'upright'}">
                        ${card.isReversed ? 'é€†ä½' : 'æ­£ä½'}
                    </span>
                </div>
                <div class="card-meaning">
                    <strong>å«ä¹‰:</strong> ${meaning}
                </div>
            `;
        }
        
        // æ·»åŠ åˆ°å†å²è®°å½•
        function addToHistory(card) {
            let displayText = card.data ? card.data.name : "æœªçŸ¥å¡ç‰Œ";
            
            if (currentMode === "number" && numberList.length > 0) {
                displayText = `å·ç  ${card.displayNumber || card.data.id + 1}`;
            } else if (currentMode === "name" && nameList.length > 0) {
                displayText = `${card.displayName || card.data.name}`;
            }
            
            history.unshift({
                name: displayText,
                isReversed: card.isReversed,
                meaning: card.isReversed ? card.data.reversed : card.data.upright,
                timestamp: new Date().toLocaleTimeString()
            });
            
            updateHistoryPanel();
        }
        
        // æ›´æ–°å†å²è®°å½•é¢æ¿
        function updateHistoryPanel() {
            const historyPanel = document.getElementById('historyPanel');
            
            if (history.length === 0) {
                historyPanel.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">æš‚æ— æŠ½å–è®°å½•</p>';
                return;
            }
            
            let historyHTML = '';
            history.forEach((item, index) => {
                historyHTML += `
                    <div class="history-item ${item.isReversed ? 'reversed' : 'upright'}">
                        <div>
                            <span class="card-name">${item.name}</span>
                            <span class="card-position ${item.isReversed ? 'reversed' : 'upright'}">
                                ${item.isReversed ? 'é€†ä½' : 'æ­£ä½'}
                            </span>
                            <span style="float: right; font-size: 0.8rem; color: #888;">${item.timestamp}</span>
                        </div>
                        <div class="card-meaning">${item.meaning}</div>
                    </div>
                `;
            });
            
            historyPanel.innerHTML = historyHTML;
        }
        
        // åˆ›å»ºæ–°å¡ç‰Œ
        function createNewCard() {
            // å¦‚æœç‰Œåº“å·²ç©ºï¼Œé‡ç½®
            if (remainingCards.length === 0) {
                remainingCards = [...tarotCards];
                
                if (currentMode === "number") {
                    updateNumberList();
                } else if (currentMode === "name") {
                    updateNameList();
                }
            }
            
            // éšæœºé€‰æ‹©ä¸€å¼ å¡ç‰Œ
            const randomIndex = Math.floor(Math.random() * remainingCards.length);
            const cardData = remainingCards[randomIndex];
            
            // åˆ›å»ºå¡ç‰Œï¼ˆèƒŒé¢æœä¸Šï¼‰
            const cardWidth = 0.6;
            const cardHeight = 1.0;
            const cardDepth = 0.02;
            
            // è®¡ç®—æ–°å¡ç‰Œçš„ä½ç½®ï¼šæ·»åŠ åˆ°ç‰Œå †æœ«å°¾
            const spacing = 1.2;
            const newX = cardDeck.length > 0 ? cardDeck[cardDeck.length - 1].originalX + spacing : 0;
            
            const card = createCard(cardWidth, cardHeight, cardDepth, false);
            card.position.set(newX, -1, 0);
            card.rotation.y = Math.PI; // èƒŒé¢æœä¸Š
            
            scene.add(card);
            
            cardDeck.push({
                group: card,
                isFaceUp: false,
                data: null, // åˆå§‹æ²¡æœ‰æ•°æ®ï¼Œæ”¾ç½®åˆ°çŸ©å½¢æ¡†æ—¶å†åˆ†é…
                isSelected: false,
                isReversed: false,
                originalX: newX,
                originalY: -1,
                floatOffset: Math.random() * Math.PI * 2
            });
        }
        
        // æ›´æ–°å·ç åˆ—è¡¨
        function updateNumberList() {
            const count = parseInt(document.getElementById('numberCount').value) || 22;
            const maxCount = Math.min(count, 100);
            
            numberList = [];
            for (let i = 1; i <= maxCount; i++) {
                numberList.push(i);
            }
        }
        
        // æ›´æ–°åå­—åˆ—è¡¨
        function updateNameList() {
            const nameText = document.getElementById('nameList').value;
            if (nameText.trim()) {
                nameList = nameText.split('\n')
                    .map(name => name.trim())
                    .filter(name => name.length > 0);
            } else {
                // ä½¿ç”¨é»˜è®¤åå­—
                nameList = ['å¼ ä¸‰', 'æå››', 'ç‹äº”', 'èµµå…­', 'é’±ä¸ƒ', 'å­™å…«', 'å‘¨ä¹', 'å´å'];
            }
        }
        
        // æŠ½å–ä¸€å¼ å¡ç‰Œ
        function drawCard() {
            // éšæœºé€‰æ‹©ä¸€ä¸ªå¡ç‰Œ
            const randomIndex = Math.floor(Math.random() * cardDeck.length);
            const card = cardDeck[randomIndex];
            
            if (card) {
                // ç¡®ä¿é€‰æ‹©çš„æ˜¯æ­£é¢æœä¸Šçš„å¡ç‰Œ
                if (card.isFaceUp) {
                    selectCard(card);
                    moveSelectedCardToFront();
                    
                    // å»¶è¿Ÿåç¡®è®¤é€‰æ‹©ï¼ˆæ¨¡æ‹Ÿæ‰‹åŠ¿ç¡®è®¤ï¼‰
                    setTimeout(() => {
                        if (selectedCard === card) {
                            confirmCardSelection();
                        }
                    }, 1500);
                } else {
                    console.warn("å°è¯•é€‰æ‹©èƒŒé¢æœä¸Šçš„å¡ç‰Œ");
                }
            }
        }
        
        // åˆ‡æ¢åˆ°é¼ æ ‡æ¨¡å¼
        function switchToMouseMode() {
            isHandMode = false;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('handModeBtn').classList.remove('active');
            document.getElementById('mouseModeBtn').classList.add('active');
            
            // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
            document.getElementById('handStatus').className = 'status-dot inactive';
            document.getElementById('handStatusText').textContent = 'é¼ æ ‡æ¨¡å¼å·²å¯ç”¨';
            
            // å…³é—­æ‘„åƒå¤´
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
                cameraStream = null;
            }
            
            document.getElementById('cameraOverlay').style.display = 'flex';
            document.getElementById('cameraOverlay').textContent = 'é¼ æ ‡æ¨¡å¼å·²å¯ç”¨';
        }
        
        // åˆ‡æ¢åˆ°æ‰‹åŠ¿æ¨¡å¼
        function switchToHandMode() {
            isHandMode = true;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.getElementById('mouseModeBtn').classList.remove('active');
            document.getElementById('handModeBtn').classList.add('active');
            
            // æ˜¾ç¤ºæ‘„åƒå¤´è¦†ç›–å±‚ï¼Œæç¤ºç­‰å¾…æ‘„åƒå¤´æƒé™
            document.getElementById('cameraOverlay').style.display = 'flex';
            document.getElementById('cameraOverlay').textContent = 'ç­‰å¾…æ‘„åƒå¤´æƒé™...';
            
            // å°è¯•å¯åŠ¨æ‘„åƒå¤´
            if (!isCameraActive) {
                initHandTracking();
            } else {
                // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                document.getElementById('handStatus').className = 'status-dot active';
                document.getElementById('handStatusText').textContent = 'æ‰‹åŠ¿è¯†åˆ«å·²å¯åŠ¨';
                // éšè—æ‘„åƒå¤´è¦†ç›–å±‚
                document.getElementById('cameraOverlay').style.display = 'none';
            }
        }
        
        // çª—å£å¤§å°è°ƒæ•´å¤„ç†
        function onWindowResize() {
            const canvas = document.getElementById('threeCanvas');
            camera.aspect = canvas.clientWidth / canvas.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }
        
        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            updateParticles();
            
            // å¡ç‰Œæµ®åŠ¨åŠ¨ç”»
            cardDeck.forEach((card, index) => {
                if (!card.isSelected) {
                    // ç¼“æ…¢æ—‹è½¬å¡ç‰Œ
                    card.group.rotation.y += 0.001;
                    
                    // ä¸Šä¸‹æµ®åŠ¨æ•ˆæœï¼Œä½¿ç”¨æ­£å¼¦å‡½æ•°åˆ›é€ å¹³æ»‘çš„æµ®åŠ¨
                    const floatSpeed = 0.001;
                    const floatAmplitude = 0.1;
                    const floatY = card.originalY + Math.sin(Date.now() * floatSpeed + card.floatOffset) * floatAmplitude;
                    card.group.position.y = floatY;
                    
                    // è½»å¾®çš„å·¦å³æ‘‡æ‘†æ•ˆæœ
                    const swaySpeed = 0.0005;
                    const swayAmplitude = 0.05;
                    const swayX = card.originalX + Math.sin(Date.now() * swaySpeed + card.floatOffset * 0.5) * swayAmplitude;
                    card.group.position.x = swayX;
                    
                    // è½»å¾®çš„æ—‹è½¬æ‘‡æ‘†
                    const rotateSpeed = 0.0003;
                    const rotateAmplitude = 0.05;
                    const rotateY = Math.PI + Math.sin(Date.now() * rotateSpeed + card.floatOffset) * rotateAmplitude;
                    card.group.rotation.y = rotateY;
                }
            });
            
            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }
        
        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–Three.js
            initThreeJS();
            
            // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
            initHandTracking();
            
            // åˆå§‹åŒ–å·ç åˆ—è¡¨
            updateNumberList();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('handModeBtn').addEventListener('click', switchToHandMode);
            document.getElementById('mouseModeBtn').addEventListener('click', switchToMouseMode);
            
            document.getElementById('numberModeBtn').addEventListener('click', function() {
                currentMode = "number";
                document.getElementById('numberModeBtn').classList.add('active');
                document.getElementById('nameModeBtn').classList.remove('active');
                document.getElementById('numberModePanel').style.display = 'block';
                document.getElementById('nameModePanel').style.display = 'none';
                updateNumberList();
            });
            
            document.getElementById('nameModeBtn').addEventListener('click', function() {
                currentMode = "name";
                document.getElementById('nameModeBtn').classList.add('active');
                document.getElementById('numberModeBtn').classList.remove('active');
                document.getElementById('numberModePanel').style.display = 'none';
                document.getElementById('nameModePanel').style.display = 'block';
                updateNameList();
            });
            
            document.getElementById('numberCount').addEventListener('change', updateNumberList);
            document.getElementById('nameList').addEventListener('input', updateNameList);
            
            document.getElementById('drawCardBtn').addEventListener('click', drawCard);
            
            // é¼ æ ‡äº‹ä»¶ç›‘å¬
            document.getElementById('threeCanvas').addEventListener('click', function(event) {
                if (!isHandMode) {
                    // è®¡ç®—é¼ æ ‡ä½ç½®
                    const rect = this.getBoundingClientRect();
                    mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                    
                    // æ›´æ–°å°„çº¿æŠ•å°„å™¨
                    raycaster.setFromCamera(mouse, camera);
                    
                    // è®¡ç®—ä¸å¡ç‰Œçš„äº¤ç‚¹
                    const intersects = raycaster.intersectObjects(cardDeck.map(card => card.group));
                    
                    if (intersects.length > 0) {
                        const clickedCard = cardDeck.find(card => card.group === intersects[0].object.parent);
                        if (clickedCard && !clickedCard.isSelected) {
                            selectCard(clickedCard);
                            moveSelectedCardToFront();
                            
                            // å»¶è¿Ÿåç¡®è®¤é€‰æ‹©
                            setTimeout(() => {
                                if (selectedCard === clickedCard) {
                                    confirmCardSelection();
                                }
                            }, 1500);
                        }
                    }
                }
            });
            
            // æ˜¾ç¤ºåˆå§‹æç¤º
            setTimeout(() => {
                if (remainingCards.length > 0) {
                    const cardInfoDiv = document.getElementById('currentCardInfo');
                    cardInfoDiv.innerHTML = `
                        <p style="text-align: center; color: #e0a96d; margin-bottom: 10px;">
                            ç‚¹å‡»"æŠ½å–ä¸€å¼ å¡ç‰Œ"æŒ‰é’®æˆ–ä½¿ç”¨æ‰‹åŠ¿å¼€å§‹æŠ½å¡
                        </p>
                        <p style="text-align: center; color: #b8b8b8; font-size: 0.9rem;">
                            æ‰‹åŠ¿æ¨¡å¼ï¼šå¼ å¼€æ‰‹æŒå‡†å¤‡ï¼ŒæåˆæŠ“å–ï¼Œæ¡æ‹³ç¡®è®¤
                        </p>
                    `;
                }
            }, 1000);
        });
    </script>
</body>
</html>
